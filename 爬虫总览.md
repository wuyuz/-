# 第一章：网络请求

## 一、urllib库

`urllib`库是`Python`中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。

### urlopen函数

在`Python3`的`urllib`库中，所有和网络请求相关的方法，都被集到`urllib.request`模块下面了，以先来看下`urlopen`函数基本的使用：

```python
from urllib import request
resp = request.urlopen('http://www.baidu.com')
print(resp.read())
```

实际上，使用浏览器访问百度，右键查看源代码。你会发现，跟我们刚才打印出来的数据是一模一样的。也就是说，上面的三行代码就已经帮我们把百度的首页的全部代码爬下来了。一个基本的url请求对应的python代码真的非常简单。
以下对`urlopen`函数的进行详细讲解：

1. `url`：请求的url。
2. `data`：请求的`data`，如果设置了这个值，那么将变成`post`请求。
3. 返回值：返回值是一个`http.client.HTTPResponse`对象，这个对象是一个类文件句柄对象。有`read(size)`、`readline`、`readlines`以及`getcode`等方法。

### urlencode函数

用浏览器发送请求的时候，如果url中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用`urlencode`函数来实现。`urlencode`可以把字典数据转换为`URL`编码的数据。示例代码如下：

```python
from urllib import parse
data = {'name':'爬虫基础','greet':'hello world','age':100}
qs = parse.urlencode(data)
print(qs)
输出：
name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&greet=hello+world&age=100
```

### request.urlretrieve函数

下载url内容到本地`request.urlretrieve(url, 路径)`

### parse_qs函数

可以将经过编码后的url参数进行解码。示例代码如下：

```python
from urllib import parse
qs = "name=%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&greet=hello+world&age=100"
print(parse.parse_qs(qs))
输出：
{'name': ['爬虫基础'], 'greet': ['hello world'], 'age': ['100']}
```

### urlparse和urlsplit

有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用`urlparse`或者是`urlsplit`来进行分割。示例代码如下：

```python
from urllib import request,parse

url = 'http://www.baidu.com/s?username=zhiliao'

result = parse.urlsplit(url)
# result = parse.urlparse(url)

print('scheme:',result.scheme)
# http
print('netloc:',result.netloc)
# www.baidu.com
print('path:',result.path)
# /s
print('query:',result.query)
# username=zhiliao
```

`urlparse`和`urlsplit`基本上是一模一样的。唯一不一样的地方是，`urlparse`里面多了一个`params`属性，而`urlsplit`没有这个`params`属性。比如有一个`url`为：`url = 'http://www.baidu.com/s;hello?wd=python&username=abc#1'`，
那么`urlparse`可以获取到params=`hello`，而`urlsplit`不可以获取到。`url`中的`params`也用得比较少。

所以，可以得出一个标准的链接格式，具体如下: 

`scheme://netloc/path;params?query#fragment`

### request.Request类

如果想要在请求的时候增加一些请求头，那么就必须使用`request.Request`类来实现。比如要增加一个`User-Agent`，示例代码如下：

```python
from urllib import request

headers = {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',
'Referer': 'https://www.lagou.com/'
}
req = request.Request("http://www.baidu.com/",headers=headers)
resp = request.urlopen(req)
print(resp.read())
```

mac报错：

```python
urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_s
```



```python
pip install certifi
/Applications/Python\ 3.6/Install\ Certificates.command
```

### ProxyHandler处理器(代理)

1. 代理的原理：在请求目的网站之前，先请求代理服务器，然后让代理服务器去请求目的网站，代理服务器拿到目的网站的数据后，再转发给我们的代码。

2. http://httpbin.org:这个网站可以方便的查看http请求的一些参数

3. 在代码中使用代理：

   * 使用`urllib.request.ProxyHandler`，传入一个代理 ，这个代理 是一个字典，字典的key依赖于代理服务器能够接收的类型，一般是是`http`或者`https`，值是`ip:port`.
   * 使用上一步创建的`handler`以及`request.build_opener`创建一个`opener`对象。
   * 使用上一步创建的`opener`，调用`open`函数，发起请求。

   示例代码如下：

   ```python
   from urllib import request
   url = 'http://httpbin.org'
   # 1、使用proxyHandler传入代理构建一个handler
   handler = request.ProxyHandler({'http':'223.241.78.43:8010'})
   # 2、使用上面创建的handler构建一个opener
   opener = request.build_opener(handler)
   # 3、使用opener去发送一个请求
   resp = opener.open(url)
   print(resp.read())
   ```

常用的代理有：

- 西刺免费代理IP：<http://www.xicidaili.com/>
- 快代理：<http://www.kuaidaili.com/>
- 代理云：<http://www.dailiyun.com/>

### 什么是cookie

在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。`cookie`的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的`cookie`数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。`cookie`存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用`cookie`只能存储一些小量的数据。

#### cookie的格式：

```python
Set-Cookie: NAME=VALUE；Expires/Max-age=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE
```

参数意义：

- NAME：cookie的名字。
- VALUE：cookie的值。 
- Expires：cookie的过期时间。
- Path：cookie作用的路径。
- Domain：cookie作用的域名。
- SECURE：是否只在https协议下起作用。

### 使用cookielib库和HTTPCookieProcessor模拟登录

Cookie 是指网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。
这里以人人网为例。人人网中，要访问某个人的主页，必须先登录才能访问，登录说白了就是要有cookie信息。那么如果我们想要用代码的方式访问，就必须要有正确的cookie信息才能访问。解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中。示例代码如下：

```python
from urllib import request,parse
# import ssl 用于解决urllib.error.URLError: <urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_s 报错的问题
# import ssl
# ssl._create_default_https_context = ssl._create_unverified_context

url = 'https://www.zhipin.com/job_detail/?query=python&city=101010100&industry=&position='
headers = {
    'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36',
    'Referer':'https://www.zhipin.com/',
    'Cookie':'_uab_collina=154235904858163773539703; lastCity=101010100; JSESSIONID=""; __c=1552973675; sid=sem_pz_bdpc_dasou_title; __g=sem_pz_bdpc_dasou_title; __l=l=%2Fwww.zhipin.com%2Fgeek%2Fattresume%2Fparser.html&r=https%3A%2F%2Fwww.zhipin.com%2F&g=%2Fwww.zhipin.com%2F%3Fsid%3Dsem_pz_bdpc_dasou_title; t=Yh3Nxvw52htct2Mh; wt=Yh3Nxvw52htct2Mh; Hm_lvt_194df3105ad7148dcf2b98a91b5e727a=1552997174,1552997195,1553135236,1553157868; __a=67768901.1538943368.1552191625.1552973675.551.8.392.377; Hm_lpvt_194df3105ad7148dcf2b98a91b5e727a=1553223056'
}
req = request.Request(url, headers=headers)
resq = request.urlopen(req)
print(resq.read().decode('utf8'))
```

但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python处理Cookie，一般是通过`http.cookiejar`模块和`urllib模块的HTTPCookieProcessor`处理器类一起使用。`http.cookiejar`模块主要作用是提供用于存储cookie的对象。而`HTTPCookieProcessor`处理器主要作用是处理这些cookie对象，并构建handler对象。

#### http.cookiejar模块：

该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。这四个类的作用分别如下：

1. CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。
2. FileCookieJar (filename,delayload=None,policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储cookie的文件名。delayload为True时支持延迟访问访问文件，即只有在需要时才读取文件或在文件中存储数据。
3. MozillaCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与Mozilla浏览器 cookies.txt兼容的FileCookieJar实例。
4. LWPCookieJar (filename,delayload=None,policy=None)：从FileCookieJar派生而来，创建与libwww-perl标准的 Set-Cookie3 文件格式兼容的FileCookieJar实例。

登录人人网：

利用`http.cookiejar`和`request.HTTPCookieProcessor`登录人人网。相关示例代码如下：

第一版：

```python
from urllib import request
from urllib import parse
from http.cookiejar import CookieJar

# 1、登陆
# 1.1 创建一个Cookiejar的对象
cookiejar = CookieJar()
# 1.2 使用request.HTTPCookieProcessor创建一个cookiejar属性的对象
handler = request.HTTPCookieProcessor(cookiejar)
# 1.3 使用上一步创建的handler创建一个opener
opener = request.build_opener(handler)
# 1.4 使用opener发送登陆的请求（网站的用户名和邮箱）
headers = {
    'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36'
}
data = {
    'username':'18993381498',
    'password':'gdpw,69213'
}
login_url = 'https://passport.lagou.com/login/login.html?signature=BDD02F0A026E28A46D5739F3BE5C4CB2&service=https%253A%252F%252Faccount.lagou.com%252Fv2%252Faccount%252FmodifyPwd.html&action=login&serviceId=account&ts=1553236371589'
req = request.Request(login_url,data=parse.urlencode(data).encode('utf8'),headers=headers)
opener.open(req)
# 访问个人主页
# 获取个人主页的时候，不要新建一个opener
# 而应该使用之前的那个opener,因为之前的那个opener已经包含了登录所需要的cookie信息
dapeng_url = "https://account.lagou.com/v2/account/userinfo.html"
req = request.Request(dapeng_url, headers=headers)
resp = opener.open(req)
print(resp.read().decode('utf8'))
with open('text.html', 'w', encoding='utf8') as fp:
    fp.write(resp.read().decode('utf8'))

```

第二版

```python
from urllib import request,parse
from http.cookiejar import CookieJar

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
}

def get_opener():
    cookiejar = CookieJar()
    handler = request.HTTPCookieProcessor(cookiejar)
    opener = request.build_opener(handler)
    return opener

def login_renren(opener):
    data = {"email": "970138074@qq.com", "password": "pythonspider"}
    data = parse.urlencode(data).encode('utf-8')
    login_url = "http://www.renren.com/PLogin.do"
    req = request.Request(login_url, headers=headers, data=data)
    opener.open(req)

def visit_profile(opener):
    url = 'http://www.renren.com/880151247/profile'
    req = request.Request(url,headers=headers)
    resp = opener.open(req)
    with open('renren.html','w') as fp:
        fp.write(resp.read().decode("utf-8"))

if __name__ == '__main__':
    opener = get_opener()
    login_renren(opener)
    visit_profile(opener)
```

#### 保存cookie到本地：

保存`cookie`到本地，可以使用`cookiejar`的`save`方法，并且需要指定一个文件名：

```python
from urllib import request
from http.cookiejar import MozillaCookieJar

cookiejar = MozillaCookieJar("cookie.txt")
handler = request.HTTPCookieProcessor(cookiejar)
opener = request.build_opener(handler)

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
}
req = request.Request('http://httpbin.org/cookies',headers=headers)

resp = opener.open(req)
print(resp.read())
cookiejar.save(ignore_discard=True,ignore_expires=True)
# ignore_discard=True 保存过期的cookie信息
```

#### 从本地加载cookie

从本地加载`cookie`，需要使用`cookiejar`的`load`方法，并且也需要指定方法：

```python
from urllib import request
from http.cookiejar import MozillaCookieJar

cookiejar = MozillaCookieJar("cookie.txt")
cookiejar.load(ignore_expires=True,ignore_discard=True)
handler = request.HTTPCookieProcessor(cookiejar)
opener = request.build_opener(handler)

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
}
req = request.Request('http://httpbin.org/cookies',headers=headers)

resp = opener.open(req)
print(resp.read())
```

## 二、requests 库

### 发送get请求

发送get请求，直接调用`requests.get`就可以了，想要 发送什么类型的请求，就调用什么方法。返回的是requests.models.Response对象。

```python
response = requests.get("http://www.baidu.com/")
```

### response 的一样属性

```python
import requests

 kw = {'wd':'中国'}

 headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36"}

 # params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()
 response = requests.get("http://www.baidu.com/s", params = kw, headers = headers)

 # 查看响应内容，response.text 返回的是Unicode格式的数据
 print(response.text)

 # 查看响应内容，response.content返回的字节流数据
 print(response.content)

 # 查看完整url地址
 print(response.url)

 # 查看响应头部字符编码
 print(response.encoding)

 # 查看响应码
 print(response.status_code)
```

#### response.text 和 response.content的区别

1. response.content： 这个是直接从网络上面抓取的数据，没有经过任何解码，所以是一个bytes类型，其实在硬盘上和网络上传输的字符串都是bytes类型
2. response.text:这个是requests,将response.content进行解码的字符串，解码需要指定一个编码方式，requests会根据自己的猜测来判断编码的方式，所有有时候可能会猜测错误，就会乱码，这时候应该使用`response.contect.decode('utf8')`进行手动解码。

### 发送post请求

最基本的POST请求可以使用`post`方法：

```python
response = requests.post("http://www.baidu.com/",data=data)
```

传入data数据：
这时候就不要再使用`urlencode`进行编码了，直接传入一个字典进去就可以了。比如请求拉勾网的数据的代码：

```python
import requests

 url = "https://www.lagou.com/jobs/positionAjax.json?city=%E6%B7%B1%E5%9C%B3&needAddtionalResult=false&isSchoolJob=0"

 headers = {
     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',
     'Referer': 'https://www.lagou.com/jobs/list_python?labelWords=&fromSearch=true&suginput='
 }

 data = {
     'first': 'true',
     'pn': 1,
     'kd': 'python'
 }

 resp = requests.post(url,headers=headers,data=data)
 # 如果是json数据，直接可以调用json方法将json字符串转化为字典或列表
 print(resp.json())
```

### 使用代理

使用`requests`添加代理也非常简单，只要在请求的方法中（比如`get`或者`post`）传递`proxies`参数就可以了。示例代码如下：

```python
import requests

url = "http://httpbin.org/get"

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',
}

proxy = {
    'http': '171.14.209.180:27829'
}

resp = requests.get(url,headers=headers,proxies=proxy)
with open('xx.html','w',encoding='utf-8') as fp:
    fp.write(resp.text)

```

### cookie

如果在一个响应中包含了`cookie`，那么可以利用`cookies`属性拿到这个返回的`cookie`值：

```python
url = "http://www.renren.com/PLogin.do"
resp = requests.get('http://www.baidu.com/')
print(resp.cookies)
print(resp.cookies.get_dict())
```

### session

之前使用`urllib`库，是可以使  用`opener`发送多个请求，多个请求之间是可以共享`cookie`的。那么如果使用`requests`，也要达到共享`cookie`的目的，那么可以使用`requests`库给我们提供的`session`对象。注意，这里的`session`不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用`requests`来实现。示例代码如下：

```python
import requests

url = "http://www.renren.com/PLogin.do"
data = {"email":"970138074@qq.com",'password':"pythonspider"}
headers = {
    'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36"
}

# 登录
session = requests.session()
session.post(url,data=data,headers=headers)

# 访问大鹏个人中心
resp = session.get('http://www.renren.com/880151247/profile')

print(resp.text)
```

### 处理不信任的SSL证书

对于那些已经被信任的SSL整数的网站，比如`https://www.baidu.com/`，那么使用`requests`直接就可以正常的返回响应。取消证书验证就行了`verify=False`示例代码如下：

```python
resp = requests.get('http://www.12306.cn/mormhweb/',verify=False)
print(resp.content.decode('utf-8'))
```

## aiohttp库

Requests库是一个阻塞式HTTP请求库，当我们发出一个请求后，程序会一直等待服务器响应，直到得到响应后，程序才会进行下一步处理。其实，这个过程比较耗费资源。如果程序可以在这个等待过程中做一些其他的事情，如进行请求的调度、响应的处理等，那么爬取效率一定会大大提高。

aiohttp就是这样一个提供异步Web服务的库，从Python 3.5版本开始，Python中加入了`async`/`await`关键字，使得回调的写法更加直观和人性化。aiohttp的异步操作借助于`async`/`await`关键字的写法变得更加简洁，架构更加清晰。使用异步请求库进行数据抓取时，会大大提高效率，下面我们来看一下这个库的安装方法。

后面的实例中用到这个库，比如维护一个代理池时，利用异步方式检测大量代理的运行状况，会极大地提升效率。

### 相关链接

- 官方文档：<http://aiohttp.readthedocs.io/en/stable>
- GitHub：<https://github.com/aio-libs/aiohttp>
- PyPI：<https://pypi.python.org/pypi/aiohttp>

###  pip安装

这里推荐使用pip安装，命令如下：

```python
pip3 install aiohttp
```

另外，官方还推荐安装如下两个库：一个是字符编码检测库cchardet，另一个是加速DNS的解析库aiodns。安装命令如下：

```python
pip3 install cchardet aiodns
```



# 第二章：数据提取

## 一、xpath语法与lxml库

### XPath语法和lxml模块

#### 什么是XPath？

xpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。

#### XPath开发工具

1. Chrome插件XPath Helper。
2. Firefox插件Try XPath。

#### XPath语法

##### 选取节点：

XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似

| bookstore       | 选取 bookstore 元素的所有子节点。                            |
| --------------- | ------------------------------------------------------------ |
| /bookstore      | 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ |
| bookstore/book  | 选取属于 bookstore 的子元素的所有 book 元素。                |
| //book          | 选取所有 book 子元素，而不管它们在文档中的位置。             |
| bookstore//book | 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 |
| //@lang         | 选取名为 lang 的所有属性。                                   |
| .. 或者parent:: | 获取父节点                                                   |

##### 谓语：

谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。
在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果：

| 路径表达式                         | 结果                                                         |
| :--------------------------------- | :----------------------------------------------------------- |
| /bookstore/book[1]                 | 选取属于 bookstore 子元素的第一个 book 元素。                |
| /bookstore/book[last()]            | 选取属于 bookstore 子元素的最后一个 book 元素。              |
| /bookstore/book[last()-1]          | 选取属于 bookstore 子元素的倒数第二个 book 元素。            |
| /bookstore/book[position()<3]      | 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。    |
| //title[@lang]                     | 选取所有拥有名为 lang 的属性的 title 元素。                  |
| //title[@lang='eng']               | 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。   |
| /bookstore/book[price>35.00]       | 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 |
| /bookstore/book[price>35.00]/title | 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 |
| //li[contains(@class, 'li')]       | class有两个属性值，li,li-fist，只要此属性值包含所传入的属性值li就可以匹配成功了 |

##### 通配符

| 通配符 | 描述                 | 示例         | 结果                            |
| :----- | :------------------- | :----------- | :------------------------------ |
| *      | 匹配任意节点         | /bookstore/* | 选取bookstore下的所有子元素。   |
| @*     | 匹配节点中的任何属性 | //book[@*]   | 选取所有带有属性的book元素。    |
| node() | 匹配任何类型的节点。 | //title[@*]  | 选取所有带有属性的 title 元素。 |

##### 选取多个路径

通过在路径表达式中使用“|”运算符，可以选取若干个路径。
示例如下：

| 路径表达式                       | 结果                                                         |
| :------------------------------- | :----------------------------------------------------------- |
| //book/title \| //book/price     | 选取 book 元素的所有 title 和 price 元素。                   |
| //title \| //price               | 选取文档中的所有 title 和 price 元素。                       |
| /bookstore/book/title \| //price | 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 |

##### 运算符

| 运算符 | 描述           | 实例                      | 返回值                                                       |
| :----- | :------------- | :------------------------ | :----------------------------------------------------------- |
| \|     | 计算两个节点集 | //book \| //cd            | 返回所有拥有 book 和 cd 元素的节点集                         |
| +      | 加法           | 6 + 4                     | 10                                                           |
| -      | 减法           | 6 - 4                     | 2                                                            |
| *      | 乘法           | 6 * 4                     | 24                                                           |
| div    | 除法           | 8 div 4                   | 2                                                            |
| =      | 等于           | price=9.80                | 如果 price 是 9.80，则返回 true。如果 price 是 9.90，则返回 false。 |
| !=     | 不等于         | price!=9.80               | 如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 |
| <      | 小于           | price<9.80                | 如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。 |
| <=     | 小于或等于     | price<=9.80               | 如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。 |
| >      | 大于           | price>9.80                | 如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 |
| >=     | 大于或等于     | price>=9.80               | 如果 price 是 9.90，则返回 true。如果 price 是 9.70，则返回 false。 |
| or     | 或             | price=9.80 or price=9.70  | 如果 price 是 9.80，则返回 true。如果 price 是 9.50，则返回 false。 |
| and    | 与             | price>9.00 and price<9.90 | 如果 price 是 9.80，则返回 true。如果 price 是 8.50，则返回 false。 |
| mod    | 计算除法的余数 | 5 mod 2                   | 1                                                            |

##### 使用方式

使用//获取整个页面当中的元素，然后写标签名，然后再写谓词进行提取比如

```
//div[@class='abc']
```

##### 需要注意的点

1. /和//区别：/代表只获取直接子节点。 // 获取子孙节点。一般//用的比较多。当然也要视情况而定
2. Contains：有时候某个属性中包含了多个值，那么可以使用`contains`函数，示例如下：

```python
//div[contains(@class,'job_detail')]
```

3. 谓词中的下调是从1开始的，不是从0开始的。
4. 获取标签属性的值

```python
//a/@href 获取所有a标签的href属性的值
```

5. 获取标签中的文本

```python
//a/text()
```



#### lxml库

lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。

lxml和正则一样，也是用 C 实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。

lxml python 官方文档：<http://lxml.de/index.html>

需要安装C语言库，可使用 pip 安装：pip install lxml

### 安装中出现 的问题

在Linux平台下安装问题不大，同样可以先尝试pip安装，如果报错，可以尝试下面的解决方案。CentOS、Red Hat对于此类系统，报错主要是因为缺少必要的库。执行如下命令安装所需的库即可：

```python
sudo yum groupinstall -y development tools
sudo yum install -y epel-release libxslt-devel libxml2-devel openssl-devel
```

主要是libxslt-devel和libxml2-devel这两个库，lxml依赖它们。安装好之后，重新尝试pip安装即可。

Ubuntu、Debian和Deepin在这些系统下，报错的原因同样可能是缺少了必要的类库，执行如下命令安装：

```python
sudo apt-get install -y python3-dev build-essential libssl-dev libffi-dev libxml2 libxml2-dev libxslt1-dev zlib1g-dev
```

Macos 如果产生错误，可以执行如下命令将必要的类库安装

```python
xcode-select --install
```

之后再重新尝试pip安装，就没有问题了。

lxml是一个非常重要的库，后面的Beautiful Soup、Scrapy框架都需要用到此库，所以请一定安装成功。

##### 基本使用：

我们可以利用他来解析HTML代码，并且在解析HTML代码的时候，如果HTML代码不规范，他会自动的进行补全。示例代码如下：

解析HTML字符串

```python
# 使用 lxml 的 etree 库
from lxml import etree 

text = '''
<div>
    <ul>
         <li class="item-0"><a href="link1.html">first item</a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a> # 注意，此处缺少一个 </li> 闭合标签
     </ul>
 </div>
'''

#利用etree.HTML，将字符串解析为HTML文档
html = etree.HTML(text) 

# 按字符串序列化HTML文档
result = etree.tostring(html, encoding='utf-8').decode('utf-8') 

print(result)
```

输出结果如下：

```html
<html><body>
<div>
    <ul>
         <li class="item-0"><a href="link1.html">first item</a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html">third item</a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a></li>
</ul>
 </div>
</body></html>
```

可以看到。lxml会自动修改HTML代码。例子中不仅补全了li标签，还添加了body，html标签。

##### 从文件中读取html代码：

除了直接使用字符串进行解析，lxml还支持从文件中读取内容。我们新建一个hello.html文件：

```html
<!-- hello.html -->
<div>
    <ul>
         <li class="item-0"><a href="link1.html">first item</a></li>
         <li class="item-1"><a href="link2.html">second item</a></li>
         <li class="item-inactive"><a href="link3.html"><span class="bold">third item</span></a></li>
         <li class="item-1"><a href="link4.html">fourth item</a></li>
         <li class="item-0"><a href="link5.html">fifth item</a></li>
     </ul>
 </div>
```

然后利用`etree.parse()`方法来读取文件。示例代码如下：

```python
from lxml import etree

# 读取外部文件 hello.html
html = etree.parse('hello.html')
result = etree.tostring(html, pretty_print=True)

print(result)
```

输出的结果和之前是相同的。这里需要注意的是，如果html代码中如果有没有闭合的标签，会报错，需要指定解析器。如果是从字符串中读取的话，etree.HTML()的话就不需要指定解析器了

```python
from lxml import etree
# 指定解析器
parser = etree.HTMLParser(encoding='utf-8')
# 读取外部文件 hello.html,指定解析器
html = etree.parse('hello.html', parser=parser)
result = etree.tostring(html, pretty_print=True).decode('utf-8')

print(result)
```

##### 在lxml中使用XPath语法

1. 获取所有li标签：

   ```python
    from lxml import etree
   
    html = etree.parse('hello.html')
    print type(html)  # 显示etree.parse() 返回类型
   
    result = html.xpath('//li')
   
    print(result)  # 打印<li>标签的元素集合
   ```

2. 获取所有li元素下的所有class属性的值：

   ```python
    from lxml import etree
   
    html = etree.parse('hello.html')
    result = html.xpath('//li/@class')
   
    print(result)
   ```

3. 获取li标签下href为`www.baidu.com`的a标签：

   ```python
    from lxml import etree
   
    html = etree.parse('hello.html')
    result = html.xpath('//li/a[@href="www.baidu.com"]')
   
    print(result)
   ```

4. 获取li标签下所有span标签：

   ```python
    from lxml import etree
   
    html = etree.parse('hello.html')
   
    #result = html.xpath('//li/span')
    #注意这么写是不对的：
    #因为 / 是用来获取子元素的，而 <span> 并不是 <li> 的子元素，所以，要用双斜杠
   
    result = html.xpath('//li//span')
   
    print(result)
   ```

5. 获取li标签下的a标签里的所有class：

   ```python
    from lxml import etree
   
    html = etree.parse('hello.html')
    result = html.xpath('//li/a//@class')
   
    print(result)
   ```

6. 获取最后一个li的a的href属性对应的值：

   ```python
    from lxml import etree
   
    html = etree.parse('hello.html')
   
    result = html.xpath('//li[last()]/a/@href')
    # 谓语 [last()] 可以找到最后一个元素
   
    print(result)
   ```

7. 获取倒数第二个li元素的内容：

   ```python
    from lxml import etree
   
    html = etree.parse('hello.html')
    result = html.xpath('//li[last()-1]/a')
   
    # text 方法可以获取元素内容
    print(result[0].text)
   ```

8. 获取倒数第二个li元素的内容的第二种方式：

   ```python
    from lxml import etree
   
    html = etree.parse('hello.html')
    result = html.xpath('//li[last()-1]/a/text()')
   
    print(result)
   ```

注意事项：

1. 使用`xpath`语法，应该使用`Element.xpath`方法，来执行xpath的选择，示例如下：

```python
trs = html.xpath("//tr[position()>1]")
```

`xpath函数`返回的永远是一个列表

2. 获取某个标签的属性：

```python
html.xpath("//a/@href") # 获取a标签的href属性对应的值
```

3. 获取文本， 是通过`xpath`中的`text()`函数

```python
address = tr.xpath("./td[4]/text()")[0]
```

4. 在某标签下，再执行xpath函数，获取这个标签下的子孙元素，那么应该在//之前加一个点，代表是在当前元素下获取，示例见上

## 二、BeautifulSoup4库

和 lxml 一样，Beautiful Soup 也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。同时还有pyquery同样是一个强大的网页解析工具，它提供了和jQuery类似的语法来解析HTML文档，支持CSS选择器，使用非常方便。
lxml 只会局部遍历，而Beautiful Soup 是基于HTML DOM（Document Object Model）的，会载入整个文档，解析整个DOM树，因此时间和内存开销都会大很多，所以性能要低于lxml。
BeautifulSoup 用来解析 HTML 比较简单，API非常人性化，支持CSS选择器、Python标准库中的HTML解析器，也支持 lxml 的 XML解析器。
Beautiful Soup 3 目前已经停止开发，推荐现在的项目使用Beautiful Soup 4。

### 安装和文档

1. 安装：`pip install bs4`。
2. 中文文档：<https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html>

### 几大解析工具对比

| 解析工具      | 解析速度 | 使用难度 |
| ------------- | -------- | -------- |
| BeautifulSoup | 最慢     | 最简单   |
| lxml          | 快       | 简单     |
| 正则          | 最快     | 最难     |

### 简单使用

```python
from bs4 import BeautifulSoup

html = """
<html><head><title>The Dormouse's story</title></head>
<body>
<p class="title" name="dromouse"><b>The Dormouse's story</b></p>
<p class="story">Once upon a time there were three little sisters; and their names were
<a href="http://example.com/elsie" class="sister" id="link1"><!-- Elsie --></a>,
<a href="http://example.com/lacie" class="sister" id="link2">Lacie</a> and
<a href="http://example.com/tillie" class="sister" id="link3">Tillie</a>;
and they lived at the bottom of a well.</p>
<p class="story">...</p>
"""

#创建 Beautiful Soup 对象
# 使用lxml来进行解析
soup = BeautifulSoup(html,"lxml")
# soup = BeautifulSoup(markup, "html5lib") # 使容错性更好的解析器,解析速度慢

print(soup.prettify())
```

### 四个常用的对象：

Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种:

1. Tag
2. NavigatableString
3. BeautifulSoup
4. Comment

#### 1. Tag：

Tag 通俗点讲就是 HTML 中的一个个标签。BeautifuSoup中所有的标签都是Tag类型的对象，并且BeautifulSoup的对象其实本质上也是一个Tag类型，是继承了Tag的类，一些方法比如find、find_all并不是BeautifulSoup的，而是Tag的。

示例代码如下：

```python
from bs4 import BeautifulSoup

html = """
<html><head><title>The Dormouse's story</title></head>
<body>
<p class="title" name="dromouse"><b>The Dormouse's story</b></p>
<p class="story">Once upon a time there were three little sisters; and their names were
<a href="http://example.com/elsie" class="sister" id="link1"><!-- Elsie --></a>,
<a href="http://example.com/lacie" class="sister" id="link2">Lacie</a> and
<a href="http://example.com/tillie" class="sister" id="link3">Tillie</a>;
and they lived at the bottom of a well.</p>
<p class="story">...</p>
"""

#创建 Beautiful Soup 对象
soup = BeautifulSoup(html,'lxml')


print soup.title
# <title>The Dormouse's story</title>

print soup.head
# <head><title>The Dormouse's story</title></head>

print soup.a
# <a class="sister" href="http://example.com/elsie" id="link1"><!-- Elsie --></a>

print soup.p
# <p class="title" name="dromouse"><b>The Dormouse's story</b></p>

print type(soup.p)
# <class 'bs4.element.Tag'>
```

我们可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是bs4.element.Tag。但是注意，它查找的是在所有内容中的第一个符合要求的标签。如果要查询所有的标签，后面会进行介绍。
对于Tag，它有两个重要的属性，分别是name和attrs。示例代码如下：

```python
print soup.name
# [document] #soup 对象本身比较特殊，它的 name 即为 [document]

print soup.head.name
# head #对于其他内部标签，输出的值便为标签本身的名称

print soup.p.attrs
# {'class': ['title'], 'name': 'dromouse'}
# 在这里，我们把 p 标签的所有属性打印输出了出来，得到的类型是一个字典。

print soup.p['class'] # soup.p.get('class')
# ['title'] #还可以利用get方法，传入属性的名称，二者是等价的

soup.p['class'] = "newClass"
print soup.p # 可以对这些属性和内容等等进行修改
# <p class="newClass" name="dromouse"><b>The Dormouse's story</b></p>
```

#### 2. NavigableString：

如果拿到标签后，还想获取标签中的内容。那么可以通过`tag.string`获取标签中的文字。继承自python中的str，用起来跟使用python的str是一样的。

示例代码如下：

```python
print soup.p.string
# The Dormouse's story

print type(soup.p.string)
# <class 'bs4.element.NavigableString'>thon
```

#### 3. BeautifulSoup：

BeautifulSoup 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 Tag 对象,它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法，通俗讲，继承自Tag。
因为 BeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name

```python
soup.name
# '[document]'
```

#### 4. Comment：

Tag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分:

```python
markup = "<b><!--Hey, buddy. Want to buy a used parser?--></b>"
soup = BeautifulSoup(markup)
comment = soup.b.string
type(comment)
# <class 'bs4.element.Comment'>
```

Comment 对象是一个特殊类型的 NavigableString 对象，继承 自NavigableString

```python
comment
# 'Hey, buddy. Want to buy a used parser'
```

### 遍历文档树：

#### 1. contents和children：

contents返回的是列表

children返回的是一个生成器

```python
html_doc = """
<html><head><title>The Dormouse's story</title></head>

<p class="title"><b>The Dormouse's story</b></p>

<p class="story">Once upon a time there were three little sisters; and their names were
<a href="http://example.com/elsie" class="sister" id="link1">Elsie</a>,
<a href="http://example.com/lacie" class="sister" id="link2">Lacie</a> and
<a href="http://example.com/tillie" class="sister" id="link3">Tillie</a>;
and they lived at the bottom of a well.</p>

<p class="story">...</p>
"""

from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc,'lxml')

head_tag = soup.head
# 返回所有子节点的列表
print(head_tag.contents)

# 返回所有子节点的迭代器
for child in head_tag.children:
    print(child)
```

#### 2. strings 和 stripped_strings

* string：获取某个标签下的非标签字符串, 返回的是一个字符串
* strings：获取某个标签下的子孙非标签字符串，返回的是一个生成器，会有空的字符串元素。
* stripped_strings：获取某个标签下的子孙非标签字符串，返回一个生成器，会去掉空白字符，生成器内不会有空字符串元素。
* get_text(): 获取某个标签下的子孙非标签字符串，不是以生成器返回，是以普通字符串返回。

### 搜索文档树：

#### 1. find和find_all方法：

搜索文档树，一般用得比较多的就是两个方法，一个是`find`，一个是`find_all`。`find`方法是找到第一个满足条件的标签后就立即返回，只返回一个元素。`find_all`方法是把所有满足条件的标签都选到，然后**返回一个列表**。使用这两个方法，最常用的用法是出入`name`以及`attr`参数找出符合要求的标签。

```python
soup.find_all("a",attrs={"id":"link2"})
```

或者是直接传入属性的的名字作为关键字参数：

```python
soup.find_all("a",id='link2')
```

有些时候，在提取标签的时候，不想提取那么多，可以使用`limit`参数限制提取多少个

```python
soup.find_all('a', limit=2, class_="link")
```

过滤条件：

* 关键字参数 ：将属性的名字作为关键字参数的名子，以及属性的值作为关键字参数的值进行过滤
* attrs参数 ：将属性的条件放到一个字典中传给attrs参数 。

获取标签的属性：

* 通过下标获取：

```python
href = a['href']
```

* 通过attrs属性获取：

```python
href = a.attrs['href']
```



#### 2. select方法：

使用以上方法可以方便的找出元素。但有时候使用`css`选择器的方式可以更加的方便。使用`css`选择器的语法，应该使用`select`方法。**返回的是一个列表**，以下列出几种常用的`css`选择器方法：

#####（1）通过标签名查找：

```python
print(soup.select('a'))
```

##### （2）通过类名查找：

通过类名，则应该在类的前面加一个`.`。比如要查找`class=sister`的标签。示例代码如下：

```python
print(soup.select('.sister'))
```

##### （3）通过id查找：

通过id查找，应该在id的名字前面加一个＃号。示例代码如下：

```python
print(soup.select("#link1"))
```

##### （4）组合查找：

组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开：

```python
print(soup.select("p #link1"))
```

直接子标签查找，则使用 > 分隔：

```python
print(soup.select("head > title"))
```

##### （5）通过属性查找：

查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。示例代码如下：

```python
print(soup.select('a[href="http://example.com/elsie"]'))
```

##### （6）获取内容

以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。

```python
soup = BeautifulSoup(html, 'lxml')
print type(soup.select('title'))
print soup.select('title')[0].get_text()

for title in soup.select('title'):
    print title.get_text()
```

## 三、正则表达式和re模块：

### 什么是正则表达式：

通俗理解：按照一定的规则，从某个字符串中匹配出想要的数据。这个规则就是正则表达式。
标准答案：<https://baike.baidu.com/item/正则表达式/1700215?fr=aladdin>

### 正则表达式常用匹配规则：

#### 匹配某个字符串：

```python
text = 'hello'
ret = re.match('he',text)
print(ret.group())
>> he
```

以上便可以在`hello`中，匹配出`he`。

#### 点（.）匹配任意的字符：

```python
text = "ab"
ret = re.match('.',text)
print(ret.group())
>> a
```

但是点（.）不能匹配不到换行符。示例代码如下：

```python
text = "ab"
ret = re.match('.',text)
print(ret.group())
>> AttributeError: 'NoneType' object has no attribute 'group'
```

#### \d匹配任意的数字：

```python
text = "123"
ret = re.match('\d',text)
print(ret.group())
>> 1
```

#### \D匹配任意的非数字：

```python
text = "a"
ret = re.match('\D',text)
print(ret.group())
>> a
```

而如果text是等于一个数字，那么就匹配不成功了。示例代码如下：

```python
text = "1"
ret = re.match('\D',text)
print(ret.group())
>> AttributeError: 'NoneType' object has no attribute 'group'
```

#### \s匹配的是空白字符（包括：\n，\t，\r和空格）：

```python
text = "\t"
ret = re.match('\s',text)
print(ret.group())
>> 空白
```

#### \w匹配的是`a-z`和`A-Z`以及数字和下划线：

```python
text = "_"
ret = re.match('\w',text)
print(ret.group())
>> _
```

而如果要匹配一个其他的字符，那么就匹配不到。示例代码如下：

```python
text = "+"
ret = re.match('\w',text)
print(ret.group())
>> AttributeError: 'NoneType' object has no attribute
```

#### \W匹配的是和\w相反的：

```python
text = "+"
ret = re.match('\W',text)
print(ret.group())
>> +
```

而如果你的text是一个下划线或者英文字符，那么就匹配不到了。示例代码如下：

```python
text = "_"
ret = re.match('\W',text)
print(ret.group())
>> AttributeError: 'NoneType' object has no attribute
```

#### []组合的方式，只要满足中括号中的某一项都算匹配成功：

```python
text = "0731-88888888"
ret = re.match('[\d\-]+',text)
print(ret.group())
>> 0731-88888888
```

之前讲到的几种匹配规则，其实可以使用中括号的形式来进行替代：

- \d：[0-9]
- \D：`[^0-9]`
- \w：[0-9a-zA-Z_]
- \W：`[^0-9a-zA-Z]`

#### 匹配多个字符：

1. `*`：可以匹配0或者任意多个字符。示例代码如下：

   ```python
    text = "0731"
    ret = re.match('\d*',text)
    print(ret.group())
    >> 0731
   ```

   以上因为匹配的要求是`\d`，那么就要求是数字，后面跟了一个星号，就可以匹配到0731这四个字符。

2. `+`：可以匹配1个或者多个字符。最少一个。示例代码如下：

   ```python
    text = "abc"
    ret = re.match('\w+',text)
    print(ret.group())
    >> abc
   ```

   因为匹配的是`\w`，那么就要求是英文字符，后面跟了一个加号，意味着最少要有一个满足`\w`的字符才能够匹配到。如果text是一个空白字符或者是一个不满足\w的字符，那么就会报错。示例代码如下：

   ```python
    text = ""
    ret = re.match('\w+',text)
    print(ret.group())
    >> AttributeError: 'NoneType' object has no attribute
   ```

3. `?`：匹配的字符可以出现一次或者不出现（0或者1）。示例代码如下：

   ```python
    text = "123"
    ret = re.match('\d?',text)
    print(ret.group())
    >> 1
   ```

4. `{m}`：匹配m个字符。示例代码如下：

   ```python
    text = "123"
    ret = re.match('\d{2}',text)
    print(ret.group())
    >> 12
   ```

5. `{m,n}`：匹配m-n个字符。在这中间的字符都可以匹配到。示例代码如下：

   ```python
    text = "123"
    ret = re.match('\d{1,2}',text)
    prit(ret.group())
    >> 12
   ```

   如果text只有一个字符，那么也可以匹配出来。示例代码如下：

   ```python
    text = "1"
    ret = re.match('\d{1,2}',text)
    prit(ret.group())
    >> 1
   ```

#### 小案例：

1. 验证手机号码：手机号码的规则是以`1`开头，第二位可以是`34587`，后面那9位就可以随意了。示例代码如下：

   ```python
    text = "18570631587"
    ret = re.match('1[34587]\d{9}',text)
    print(ret.group())
    >> 18570631587
   ```

   而如果是个不满足条件的手机号码。那么就匹配不到了。示例代码如下：

   ```python
    text = "1857063158"
    ret = re.match('1[34587]\d{9}',text)
    print(ret.group())
    >> AttributeError: 'NoneType' object has no attribute
   ```

2. 验证邮箱：邮箱的规则是邮箱名称是用`数字、数字、下划线`组成的，然后是`@`符号，后面就是域名了。示例代码如下：

   ```python
    text = "hynever@163.com"
    ret = re.match('\w+@\w+\.[a-zA-Z\.]+',text)
    print(ret.group())
   ```

3. 验证URL：URL的规则是前面是`http`或者`https`或者是`ftp`然后再加上一个冒号，再加上一个斜杠，再后面就是可以出现任意非空白字符了。示例代码如下：

   ```python
    text = "http://www.baidu.com/"
    ret = re.match('(http|https|ftp)://[^\s]+',text)
    print(ret.group())
   ```

4. 验证身份证：身份证的规则是，总共有18位，前面17位都是数字，后面一位可以是数字，也可以是小写的x，也可以是大写的X。示例代码如下：

   ```python
    text = "3113111890812323X"
    ret = re.match('\d{17}[\dxX]',text)
    print(ret.group())
   ```

#### ^（脱字号）：表示以...开始：

```python
text = "hello"
ret = re.match('^h',text)
print(ret.group())
```

如果是在中括号中，那么代表的是取反操作.

#### $：表示以...结束：

```python
# 匹配163.com的邮箱
text = "xxx@163.com"
ret = re.search('\w+@163\.com$',text)
print(ret.group())
>> xxx@163.com
```

#### |：匹配多个表达式或者字符串：

```python
text = "hello|world"
ret = re.search('hello',text)
print(ret.group())
>> hello
```

#### 贪婪模式和非贪婪模式：

贪婪模式：正则表达式会匹配尽量多的字符。默认是贪婪模式。
非贪婪模式：正则表达式会尽量少的匹配字符。
示例代码如下：

```python
text = "0123456"
ret = re.match('\d+',text)
print(ret.group())
# 因为默认采用贪婪模式，所以会输出0123456
>> 0123456
```

可以改成非贪婪模式，那么就只会匹配到0。示例代码如下：

```python
text = "0123456"
ret = re.match('\d+?',text)
print(ret.group())
```

#### 案例：匹配`0-100`之间的数字：

```python
text = '99'
ret = re.match('[1-9]?\d$|100$',text)
print(ret.group())
>> 99
```

而如果`text=101`，那么就会抛出一个异常。示例代码如下：

```python
text = '101'
ret = re.match('[1-9]?\d$|100$',text)
print(ret.group())
>> AttributeError: 'NoneType' object has no attribute 'group'
```

#### 转义字符和原生字符串：

在正则表达式中，有些字符是有特殊意义的字符。因此如果想要匹配这些字符，那么就必须使用反斜杠进行转义。比如`$`代表的是以...结尾，如果想要匹配`$`，那么就必须使用`\$`。示例代码如下：

```python
text = "apple price is \$99,orange paice is $88"
ret = re.search('\$(\d+)',text)
print(ret.group())
>> $99
```

原生字符串：
在正则表达式中，`\`是专门用来做转义的。在Python中`\`也是用来做转义的。因此如果想要在普通的字符串中匹配出`\`，那么要给出四个`\`。示例代码如下：

```python
text = "apple \c"
ret = re.search('\\\\c',text)
print(ret.group())
```

因此要使用原生字符串就可以解决这个问题：

```python
text = "apple \c"
ret = re.search(r'\\c',text)
print(ret.group())
```

### re模块中常用函数：

#### match：

从开始的位置进行匹配。如果开始的位置没有匹配到。就直接失败了。示例代码如下：

```python
text = 'hello'
ret = re.match('h',text)
print(ret.group())
>> h
```

如果第一个字母不是`h`，那么就会失败。示例代码如下：

```python
text = 'ahello'
ret = re.match('h',text)
print(ret.group())
>> AttributeError: 'NoneType' object has no attribute 'group'
```

如果想要匹配换行的数据，那么就要传入一个`flag=re.DOTALL`，就可以匹配换行符了。示例代码如下：

```python
text = "abc\nabc"
ret = re.match('abc.*abc',text,re.DOTALL)
print(ret.group())
```

#### search：

在字符串中找满足条件的字符。如果找到，就返回。说白了，就是只会找到第一个满足条件的。

```python
text = 'apple price $99 orange price $88'
ret = re.search('\d+',text)
print(ret.group())
>> 99
```

#### 分组：

在正则表达式中，可以对过滤到的字符串进行分组。分组使用圆括号的方式。

1. `group`：和`group(0)`是等价的，返回的是整个满足条件的字符串。
2. `groups`：返回的是里面的子组。索引从1开始。
3. `group(1)`：返回的是第一个子组，可以传入多个。
   示例代码如下：

```python
text = "apple price is $99,orange price is $10"
ret = re.search(r".*(\$\d+).*(\$\d+)",text)
print(ret.group())
print(ret.group(0))
print(ret.group(1))
print(ret.group(2))
print(ret.groups())
```

#### findall：

找出所有满足条件的，返回的是一个列表。

```python
text = 'apple price $99 orange price $88'
ret = re.findall('\d+',text)
print(ret)
>> ['99', '88']
```

#### sub：

用来替换字符串。将匹配到的字符串替换为其他字符串。

```python
text = 'apple price $99 orange price $88'
ret = re.sub('\d+','0',text)
print(ret)
>> apple price $0 orange price $0
```

`sub`函数的案例，获取拉勾网中的数据：

```python
html = """
<div>
<p>基本要求：</p>
<p>1、精通HTML5、CSS3、 JavaScript等Web前端开发技术，对html5页面适配充分了解，熟悉不同浏览器间的差异，熟练写出兼容各种浏览器的代码；</p>
<p>2、熟悉运用常见JS开发框架，如JQuery、vue、angular，能快速高效实现各种交互效果；</p>
<p>3、熟悉编写能够自动适应HTML5界面，能让网页格式自动适应各款各大小的手机；</p>
<p>4、利用HTML5相关技术开发移动平台、PC终端的前端页面，实现HTML5模板化；</p>
<p>5、熟悉手机端和PC端web实现的差异，有移动平台web前端开发经验，了解移动互联网产品和行业，有在Android,iOS等平台下HTML5+CSS+JavaScript（或移动JS框架）开发经验者优先考虑；6、良好的沟通能力和团队协作精神，对移动互联网行业有浓厚兴趣，有较强的研究能力和学习能力；</p>
<p>7、能够承担公司前端培训工作，对公司各业务线的前端（HTML5\CSS3）工作进行支撑和指导。</p>
<p><br></p>
<p>岗位职责：</p>
<p>1、利用html5及相关技术开发移动平台、微信、APP等前端页面，各类交互的实现；</p>
<p>2、持续的优化前端体验和页面响应速度，并保证兼容性和执行效率；</p>
<p>3、根据产品需求，分析并给出最优的页面前端结构解决方案；</p>
<p>4、协助后台及客户端开发人员完成功能开发和调试；</p>
<p>5、移动端主流浏览器的适配、移动端界面自适应研发。</p>
</div>
"""

ret = re.sub('</?[a-zA-Z0-9]+>',"",html)
print(ret)
```

#### split：

使用正则表达式来分割字符串。

```python
text = "hello world ni hao"
ret = re.split('\W',text)
print(ret)
>> ["hello","world","ni","hao"]
```

#### compile：

对于一些经常要用到的正则表达式，可以使用`compile`进行编译，后期再使用的时候可以直接拿过来用，执行效率会更快。而且`compile`还可以指定`flag=re.VERBOSE`，在写正则表达式的时候可以做好注释。示例代码如下：

```python
text = "the number is 20.50"
r = re.compile(r"""
                \d+ # 小数点前面的数字
                \.? # 小数点
                \d* # 小数点后面的数字
                """,re.VERBOSE)
ret = re.search(r,text)
print(ret.group())
```

# 第三章 数据存储

## 一、json文件处理：

### 什么是json：

JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。更多解释请见：<https://baike.baidu.com/item/JSON/2462549?fr=aladdin>

### JSON支持数据格式：

1. 对象（字典）。使用花括号。
2. 数组（列表）。使用方括号。
3. 整形、浮点型、布尔类型还有null类型。
4. 字符串类型（字符串必须要用双引号，不能用单引号）。

多个数据之间使用逗号分开。
**注意：json本质上就是一个字符串。**

### 字典和列表转JSON：

```python
import json

books = [
    {
        'title': '钢铁是怎样练成的',
        'price': 9.8
    },
    {
        'title': '红楼梦',
        'price': 9.9
    }
]

json_str = json.dumps(books,ensure_ascii=False)
print(json_str)
```

因为`json`在`dump`的时候，只能存放`ascii`的字符，因此会将中文进行转义，这时候我们可以使用`ensure_ascii=False`关闭这个特性。
在`Python`中。只有基本数据类型才能转换成`JSON`格式的字符串。也即：`int`、`float`、`str`、`list`、`dict`、`tuple`。

### 将json数据直接`dump`到文件中：

`json`模块中除了`dumps`函数，还有一个`dump`函数，这个函数可以传入一个文件指针，直接将字符串`dump`到文件中。示例代码如下：

```python
books = [
    {
        'title': '钢铁是怎样练成的',
        'price': 9.8
    },
    {
        'title': '红楼梦',
        'price': 9.9
    }
]
with open('a.json','w') as fp:
    json.dump(books,fp)
```

### 将一个json字符串load成Python对象：

```python
json_str = '[{"title": "钢铁是怎样练成的", "price": 9.8}, {"title": "红楼梦", "price": 9.9}]'
books = json.loads(json_str,encoding='utf-8')
print(type(books))
print(books)
```

### 直接从文件中读取json：

```python
import json
with open('a.json','r',encoding='utf-8') as fp:
    json_str = json.load(fp)
    print(json_str)
```

## csv文件处理

### 读取csv文件：

```python
import csv

with open('stock.csv','r') as fp:
    reader = csv.reader(fp) # reader 是一个迭代器，返回的是一个列表
    titles = next(reader)
    for x in reader:
        print(x)
```

这样操作，以后获取数据的时候，就要通过下表来获取数据。如果想要在获取数据的时候通过标题来获取。那么可以使用`DictReader`。示例代码如下：

```python
import csv

with open('stock.csv','r') as fp:
    reader = csv.DictReader(fp) # reader是一个迭代器，遍历这个迭代器，返回的是一个字典
    for x in reader:
        print(x['turnoverVol'])
```

### 写入数据到csv文件：

写入数据到csv文件，需要创建一个`writer`对象，主要用到两个方法。一个是`writerow`，这个是写入一行。一个是`writerows`，这个是写入多行。示例代码如下：

```python
import csv

headers = ['name','age','classroom']
values = [
    ('zhiliao',18,'111'),
    ('wena',20,'222'),
    ('bbc',21,'111')
]
with open('test.csv','w',newline='', encoding='utf-8') as fp:
    writer = csv.writer(fp)
    writer.writerow(headers)
    writer.writerows(values)
```

也可以使用字典的方式把数据写入进去。这时候就需要使用`DictWriter`了。示例代码如下：

```python
import csv

headers = ['name','age','classroom']
values = [
    {"name":'wenn',"age":20,"classroom":'222'},
    {"name":'abc',"age":30,"classroom":'333'}
]
with open('test.csv','w',newline='', encoding='utf-8') as fp:
    writer = csv.DictWriter(fp,headers)
    writer = csv.writeheader() # 需要手动的写入表头信息
    # writer.writerow({'name':'zhiliao',"age":18,"classroom":'111'}) # 一交性写入一个字典
    writer.writerows(values)
```

## MySQL数据库操作

### 安装mysql：

1. 在官网：<https://dev.mysql.com/downloads/windows/installer/5.7.html>
2. 如果提示没有`.NET Framework`框架。那么就在提示框中找到下载链接，下载一个就可以了。
3. 如果提示没有`Microsoft Virtual C++ x64(x86)`，那么百度或者谷歌这个软件安装即可。
4. 如果没有找到。那么私聊我。

### navicat：

navicat是一个操作mysql数据库非常方便的软件。使用他操作数据库，就跟使用excel操作数据是一样的。

### 安装驱动程序：

Python要想操作MySQL。必须要有一个中间件，或者叫做驱动程序。驱动程序有很多。比如有`mysqldb`、`mysqlclient`、`pymysql`等。在这里，我们选择用`pymysql`。安装方式也是非常简单，通过命令`pip install pymysql`即可安装。

### 数据库连接：

数据库连接之前。首先先确认以下工作完成，这里我们以一个`pymysql_test`数据库.以下将介绍连接`mysql`的示例代码：

```python
    import pymysql

    db = pymysql.connect(
        host="127.0.0.1",
        user='root',
        password='root',
        database='pymysql_test',
        port=3306
    )
    cursor = db.cursor()
    cursor.execute("select 1")
    data = cursor.fetchone()
    print(data)
    db.close()
```

### 插入数据：

```python
import pymysql

db = pymysql.connect(
    host="127.0.0.1",
    user='root',
    password='root',
    database='pymysql_test',
    port=3306
)
cursor = db.cursor()
sql = """
insert into user(
    id,username,gender,age,password
  ) 
  values(null,'abc',1,18,'111111');
"""
cursor.execute(sql)
db.commit()
db.close()
```

如果在数据还不能保证的情况下，可以使用以下方式来插入数据：

```python
sql = """
insert into user(
    id,username,gender,age,password
  ) 
  values(null,%s,%s,%s,%s);
"""

cursor.execute(sql,('spider',1,20,'222222'))
```

### 查找数据：

使用`pymysql`查询数据。可以使用`fetch*`方法。

1. `fetchone()`：这个方法每次之获取一条数据。
2. `fetchall()`：这个方法接收全部的返回结果。
3. `fetchmany(size)`：可以获取指定条数的数据。
   示例代码如下：

```python
cursor = db.cursor()

sql = """
select * from user
"""

cursor.execute(sql)
while True:
    result = cursor.fetchone()
    if not result:
        break
    print(result)
db.close()
```

或者是直接使用`fetchall`，一次性可以把所有满足条件的数据都取出来：

```python
cursor = db.cursor()

sql = """
select * from user
"""

cursor.execute(sql)
results = cursor.fetchall()
for result in results:
    print(result)
db.close()
```

或者是使用`fetchmany`，指定获取多少条数据：

```python
cursor = db.cursor()

sql = """
select * from user
"""

cursor.execute(sql)
results = cursor.fetchmany(1)
for result in results:
    print(result)
db.close()
```

### 删除数据：

```python
cursor = db.cursor()

sql = """
delete from user where id=1
"""

cursor.execute(sql)
db.commit()
db.close()
```

### 更新数据：

```python
conn = pymysql.connect(host='localhost',user='root',password='root',database='pymysql_demo',port=3306)
cursor = conn.cursor()

sql = """
update user set username='aaa' where id=1
"""
cursor.execute(sql)
conn.commit()

conn.close()
```

## mongodb 数据库操作





# 第四章 爬虫进阶

## 一、多线程爬虫

有些时候，比如下载图片，因为下载图片是一个耗时的操作。如果采用之前那种同步的方式下载。那效率肯会特别慢。这时候我们就可以考虑使用多线程的方式来下载图片。

### 多线程介绍：

多线程是为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。
最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也可以有多节车厢。多线程的出现就是为了提高效率。同时它的出现也带来了一些问题。更多介绍请参考：<https://baike.baidu.com/item/多线程/1190404?fr=aladdin>

### threading模块介绍：

`threading`模块是`python`中专门提供用来做多线程编程的模块。`threading`模块中最常用的类是`Thread`。以下看一个简单的多线程程序：

```python
import threading
import time

def coding():
    for x in range(3):
        print('%s正在写代码' % x)
        time.sleep(1)

def drawing():
    for x in range(3):
        print('%s正在画图' % x)
        time.sleep(1)


def single_thread():
    coding()
    drawing()

def multi_thread():
    t1 = threading.Thread(target=coding)
    t2 = threading.Thread(target=drawing)

    t1.start()
    t2.start()

if __name__ == '__main__':
    multi_thread()
```

### 查看线程数：

使用`threading.enumerate()`函数便可以看到当前线程的数量。

### 查看当前线程的名字：

使用`threading.current_thread()`可以看到当前线程的信息。

### 继承自`threading.Thread`类：

为了让线程代码更好的封装。可以使用`threading`模块下的`Thread`类，继承自这个类，然后实现`run`方法，线程就会自动运行`run`方法中的代码。示例代码如下：

```python
import threading
import time

class CodingThread(threading.Thread):
    def run(self):
        for x in range(3):
            print('%s正在写代码' % threading.current_thread())
            time.sleep(1)

class DrawingThread(threading.Thread):
    def run(self):
        for x in range(3):
            print('%s正在画图' % threading.current_thread())
            time.sleep(1)

def multi_thread():
    t1 = CodingThread()
    t2 = DrawingThread()

    t1.start()
    t2.start()

if __name__ == '__main__':
    multi_thread()
```

### 多线程共享全局变量的问题：

多线程都是在同一个进程中运行的。因此在进程中的全局变量所有线程都是可共享的。这就造成了一个问题，因为线程执行的顺序是无序的。有可能会造成数据错误。比如以下代码：

```python
import threading

tickets = 0

def get_ticket():
    global tickets
    for x in range(1000000):
        tickets += 1
    print('tickets:%d'%tickets)

def main():
    for x in range(2):
        t = threading.Thread(target=get_ticket)
        t.start()

if __name__ == '__main__':
    main()
```

以上结果正常来讲应该是6，但是因为多线程运行的不确定性。因此最后的结果可能是随机的。

### 锁机制：

为了解决以上使用共享全局变量的问题。`threading`提供了一个`Lock`类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时就不能进来，直到当前线程处理完后，把锁释放了，其他线程才能进来处理。示例代码如下：

```python
import threading

VALUE = 0

gLock = threading.Lock()

def add_value():
    global VALUE
    gLock.acquire()
    for x in range(1000000):
        VALUE += 1
    gLock.release()
    print('value：%d'%VALUE)

def main():
    for x in range(2):
        t = threading.Thread(target=add_value)
        t.start()

if __name__ == '__main__':
    main()
```

### Lock版本生产者和消费者模式：

生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。但是因为要使用中间变量，中间变量经常是一些全局变量，因此需要使用锁来保证数据完整性。以下是使用`threading.Lock`锁实现的“生产者与消费者模式”的一个例子：

```python
import threading
import random
import time

gMoney = 1000
gLock = threading.Lock()
# 记录生产者生产的次数，达到10次就不再生产
gTimes = 0

class Producer(threading.Thread):
    def run(self):
        global gMoney
        global gLock
        global gTimes
        while True:
            money = random.randint(100, 1000)
            gLock.acquire()
            # 如果已经达到10次了，就不再生产了
            if gTimes >= 10:
                gLock.release()
                break
            gMoney += money
            print('%s当前存入%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney))
            gTimes += 1
            time.sleep(0.5)
            gLock.release()

class Consumer(threading.Thread):
    def run(self):
        global gMoney
        global gLock
        global gTimes
        while True:
            money = random.randint(100, 500)
            gLock.acquire()
            if gMoney > money:
                gMoney -= money
                print('%s当前取出%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney))
                time.sleep(0.5)
            else:
                # 如果钱不够了，有可能是已经超过了次数，这时候就判断一下
                if gTimes >= 10:
                    gLock.release()
                    break
                print("%s当前想取%s元钱，剩余%s元钱，不足！" % (threading.current_thread(),money,gMoney))
            gLock.release()

def main():
    for x in range(5):
        Consumer(name='消费者线程%d'%x).start()

    for x in range(5):
        Producer(name='生产者线程%d'%x).start()

if __name__ == '__main__':
    main()
```

### Condition版的生产者与消费者模式：

`Lock`版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过`while True`死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用`threading.Condition`来实现。`threading.Condition`可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用`notify`相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。首先对`threading.Condition`相关的函数做个介绍，`threading.Condition`类似`threading.Lock`，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下将一些常用的函数做个简单的介绍：

1. `acquire`：上锁。
2. `release`：解锁。
3. `wait`：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用`notify`和`notify_all`函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。
4. `notify`：通知某个正在等待的线程，默认是第1个等待的线程。
5. `notify_all`：通知所有正在等待的线程。`notify`和`notify_all`不会释放锁。并且需要在`release`之前调用。

`Condition`版的生产者与消费者模式代码如下：

```python
import threading
import random
import time

gMoney = 1000
gCondition = threading.Condition()
gTimes = 0
gTotalTimes = 5

class Producer(threading.Thread):
    def run(self):
        global gMoney
        global gCondition
        global gTimes
        while True:
            money = random.randint(100, 1000)
            gCondition.acquire()
            if gTimes >= gTotalTimes:
                gCondition.release()
                print('当前生产者总共生产了%s次'%gTimes)
                break
            gMoney += money
            print('%s当前存入%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney))
            gTimes += 1
            time.sleep(0.5)
            gCondition.notify_all()
            gCondition.release()

class Consumer(threading.Thread):
    def run(self):
        global gMoney
        global gCondition
        while True:
            money = random.randint(100, 500)
            gCondition.acquire()
            # 这里要给个while循环判断，因为等轮到这个线程的时候
            # 条件有可能又不满足了
            while gMoney < money:
                if gTimes >= gTotalTimes:
                    gCondition.release()
                    return
                print('%s准备取%s元钱，剩余%s元钱，不足！'%(threading.current_thread(),money,gMoney))
                gCondition.wait()
            gMoney -= money
            print('%s当前取出%s元钱，剩余%s元钱' % (threading.current_thread(), money, gMoney))
            time.sleep(0.5)
            gCondition.release()

def main():
    for x in range(5):
        Consumer(name='消费者线程%d'%x).start()

    for x in range(2):
        Producer(name='生产者线程%d'%x).start()

if __name__ == '__main__':
    main()
```

### Queue线程安全队列：

在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做`queue`模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下：

1. 初始化Queue(maxsize)：创建一个先进先出的队列。
2. qsize()：返回队列的大小。
3. empty()：判断队列是否为空。
4. full()：判断队列是否满了。
5. get()：从队列中取最后一个数据。参数默认block=True，代表没有值就阻塞
6. put()：将一个数据放到队列中。

### 使用生产者与消费者模式多线程下载表情包：

```python
import threading
import requests
from lxml import etree
from urllib import request
import os
import re
from queue import Queue

class Producer(threading.Thread):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
    }
    def __init__(self,page_queue,img_queue,*args,**kwargs):
        super(Producer, self).__init__(*args,**kwargs)
        self.page_queue = page_queue
        self.img_queue = img_queue


    def run(self):
        while True:
            if self.page_queue.empty():
                break
            url = self.page_queue.get()
            self.parse_page(url)

    def parse_page(self,url):
        response = requests.get(url,headers=self.headers)
        text = response.text
        html = etree.HTML(text)
        imgs = html.xpath("//div[@class='page-content text-center']//a//img")
        for img in imgs:
            if img.get('class') == 'gif':
                continue
            img_url = img.xpath(".//@data-original")[0]
            suffix = os.path.splitext(img_url)[1]
            alt = img.xpath(".//@alt")[0]
            alt = re.sub(r'[，。？?,/\\·]','',alt)
            img_name = alt + suffix
            self.img_queue.put((img_url,img_name))

class Consumer(threading.Thread):
    def __init__(self,page_queue,img_queue,*args,**kwargs):
        super(Consumer, self).__init__(*args,**kwargs)
        self.page_queue = page_queue
        self.img_queue = img_queue

    def run(self):
        while True:
            if self.img_queue.empty():
                if self.page_queue.empty():
                    return
            img = self.img_queue.get(block=True)
            url,filename = img
            request.urlretrieve(url,'images/'+filename)
            print(filename+'  下载完成！')

def main():
    page_queue = Queue(100)
    img_queue = Queue(500)
    for x in range(1,101):
        url = "http://www.doutula.com/photo/list/?page=%d" % x
        page_queue.put(url)

    for x in range(5):
        t = Producer(page_queue,img_queue)
        t.start()

    for x in range(5):
        t = Consumer(page_queue,img_queue)
        t.start()

if __name__ == '__main__':
    main()
```

### GIL全局解释器锁：

Python自带的解释器是`CPython`。`CPython`解释器的多线程实际上是一个假的多线程（在多核CPU中，只能利用一核，不能利用多核）。同一时刻只有一个线程在执行，为了保证同一时刻只有一个线程在执行，在`CPython`解释器中有一个东西叫做`GIL（Global Intepreter Lock）`，叫做全局解释器锁。这个解释器锁是有必要的。因为`CPython`解释器的内存管理不是线程安全的。当然除了`CPython`解释器，还有其他的解释器，有些解释器是没有`GIL`锁的，见下面：

1. `Jython`：用Java实现的Python解释器。不存在GIL锁。更多详情请见：<https://zh.wikipedia.org/wiki/Jython>
2. `IronPython`：用`.net`实现的Python解释器。不存在GIL锁。更多详情请见：<https://zh.wikipedia.org/wiki/IronPython>
3. `PyPy`：用`Python`实现的Python解释器。存在GIL锁。更多详情请见：<https://zh.wikipedia.org/wiki/PyPy>
   GIL虽然是一个假的多线程。但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。

### 多线程下载百思不得姐段子作业：

```python
import requests
from lxml import etree
import threading
from queue import Queue
import csv


class BSSpider(threading.Thread):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
    }
    def __init__(self,page_queue,joke_queue,*args,**kwargs):
        super(BSSpider, self).__init__(*args,**kwargs)
        self.base_domain = 'http://www.budejie.com'
        self.page_queue = page_queue
        self.joke_queue = joke_queue

    def run(self):
        while True:
            if self.page_queue.empty():
                break
            url = self.page_queue.get()
            response = requests.get(url, headers=self.headers)
            text = response.text
            html = etree.HTML(text)
            descs = html.xpath("//div[@class='j-r-list-c-desc']")
            for desc in descs:
                jokes = desc.xpath(".//text()")
                joke = "\n".join(jokes).strip()
                link = self.base_domain+desc.xpath(".//a/@href")[0]
                self.joke_queue.put((joke,link))
            print('='*30+"第%s页下载完成！"%url.split('/')[-1]+"="*30)

class BSWriter(threading.Thread):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'
    }

    def __init__(self, joke_queue, writer,gLock, *args, **kwargs):
        super(BSWriter, self).__init__(*args, **kwargs)
        self.joke_queue = joke_queue
        self.writer = writer
        self.lock = gLock

    def run(self):
        while True:
            try:
                joke_info = self.joke_queue.get(timeout=40)
                joke,link = joke_info
                self.lock.acquire()
                self.writer.writerow((joke,link))
                self.lock.release()
                print('保存一条')
            except:
                break

def main():
    page_queue = Queue(10)
    joke_queue = Queue(500)
    gLock = threading.Lock()
    fp = open('bsbdj.csv', 'a',newline='', encoding='utf-8')
    writer = csv.writer(fp)
    writer.writerow(('content', 'link'))

    for x in range(1,11):
        url = 'http://www.budejie.com/text/%d' % x
        page_queue.put(url)

    for x in range(5):
        t = BSSpider(page_queue,joke_queue)
        t.start()

    for x in range(5):
        t = BSWriter(joke_queue,writer,gLock)
        t.start()

if __name__ == '__main__':
    main()
```

## 二、动态网页数据抓取

### 什么是AJAX：

AJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax）如果需要更新内容，必须重载整个网页页面。因为传统的在传输数据格式方面，使用的是`XML`语法。因此叫做`AJAX`，其实现在数据交互基本上都是使用`JSON`。使用AJAX加载的数据，即使使用了JS，将数据渲染到了浏览器中，在`右键->查看网页源代码`还是不能看到通过ajax加载的数据，只能看到使用这个url加载的html代码。

### 获取ajax数据的方式：

1. 直接分析ajax调用的接口。然后通过代码请求这个接口。
2. 使用Selenium+chromedriver模拟浏览器行为获取数据。

| 方式     | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分析接口 | 直接可以请求到数据。不需要做一些解析工作。代码量少，性能高。 | 分析接口比较复杂，特别是一些通过js混淆的接口，要有一定的js功底。容易被发现是爬虫。 |
| selenium | 直接模拟浏览器的行为。浏览器能请求到的，使用selenium也能请求到。爬虫更稳定。 | 代码量多。性能低。                                           |

### Selenium+chromedriver获取动态数据：

`Selenium`相当于是一个机器人。可以模拟人类在浏览器上的一些行为，自动处理浏览器上的一些行为，比如点击，填充数据，删除cookie等。`chromedriver`是一个驱动`Chrome`浏览器的驱动程序，使用他才可以驱动浏览器。当然针对不同的浏览器有不同的driver。以下列出了不同浏览器及其对应的driver：

1. Chrome：<https://sites.google.com/a/chromium.org/chromedriver/downloads>
2. Firefox：<https://github.com/mozilla/geckodriver/releases>
3. Edge：<https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/>
4. Safari：<https://webkit.org/blog/6900/webdriver-support-in-safari-10/>
5. PhantomJS：<http://phantomjs.org/download.html>不会发现有浏览器弹出，效率高

#### 安装Selenium和chromedriver：

1. 安装有很多语言的版本，有java、ruby、python等。我们下载python版本的就可以了。

   ```shell
    pip install selenium
   ```

2. 安装`chromedriver`：下载完成后，放到不需要权限的纯英文目录下就可以了。

#### 快速入门：

现在以一个简单的获取百度首页的例子来讲下`Selenium`和`chromedriver`如何快速入门：

```python
from selenium import webdriver

# chromedriver的绝对路径
driver_path = r'D:\ProgramApp\chromedriver\chromedriver.exe'

# 初始化一个driver，并且指定chromedriver的路径
driver = webdriver.Chrome(executable_path=driver_path)
# 请求网页
driver.get("https://www.baidu.com/")
# 通过page_source获取网页源代码
print(driver.page_source)
```

隐藏浏览器不弹出浏览器界面运行

```python
from selenium.webdriver.chrome.options import Options
from selenium.webdriver import Chrome

options = Options()
options.add_argument('--headless')
browser = Chrome('./chromedriver', chrome_options=options)
browser.get('http://www.baidu.com')
print(browser.current_url)
```



PhantomJs的使用

新版本的Selenium不再支持PhantomJS了

在Selenium中使用的话，我们只需要将Chrome切换为PhantomJS即可：

```python
from selenium import webdriver
browser = webdriver.PhantomJS()
browser.get('https://www.baidu.com')
print(browser.current_url)
## https://www.baidu.com/
```

#### selenium常用操作：

更多教程请参考：<http://selenium-python.readthedocs.io/installation.html#introduction>

#### 关闭页面：

1. `driver.close()`：关闭当前页面。
2. `driver.quit()`：退出整个浏览器。

#### 定位元素：

1. ```
   find_element_by_id
   ```

   ：根据id来查找某个元素。等价于：

   ```python
    submitTag = driver.find_element_by_id('su')
    submitTag1 = driver.find_element(By.ID,'su')
   ```

2. ```
   find_element_by_class_name
   ```

   ：根据类名查找元素。 等价于：

   ```python
    submitTag = driver.find_element_by_class_name('su')
    submitTag1 = driver.find_element(By.CLASS_NAME,'su')
   ```

3. ```
   find_element_by_name
   ```

   ：根据name属性的值来查找元素。等价于：

   ```python
    submitTag = driver.find_element_by_name('email')
    submitTag1 = driver.find_element(By.NAME,'email')
   ```

4. ```
   find_element_by_tag_name
   ```

   ：根据标签名来查找元素。等价于：

   ```python
    submitTag = driver.find_element_by_tag_name('div')
    submitTag1 = driver.find_element(By.TAG_NAME,'div')
   ```

5. ```
   find_element_by_xpath
   ```

   ：根据xpath语法来获取元素。等价于：

   ```python
    submitTag = driver.find_element_by_xpath('//div')
    submitTag1 = driver.find_element(By.XPATH,'//div')
   ```

6. `find_element_by_css_selector`：根据css选择器选择元素。等价于：

   ```python
    submitTag = driver.find_element_by_css_selector('//div')
    submitTag1 = driver.find_element(By.CSS_SELECTOR,'//div')
   ```

   要注意，`find_element`是获取第一个满足条件的元素。`find_elements`是获取所有满足条件的元素。

   1. 如果只是想要解析网页中的数据，那么推荐将网页源代码扔给lxml来解析，因为lxml底层使用的是C语言，所以解析效率会更高。
   2. 如果只是想对元素进行一些操作，比如给一个文本框输入值，或者是点击某个按钮，那么就必须使用selenium给我们提供查找元素的方法。

#### 获取元素信息

##### 1. 获取属性 get_attribute("属性名")

```python
from selenium import webdriver
from selenium.webdriver import ActionChains

browser = webdriver.Chrome()
url = 'https://www.zhihu.com/explore'
browser.get(url)
logo = browser.find_element_by_id('zh-top-link-logo')
print(logo)
print(logo.get_attribute('class'))
```

##### 2. 获取文本值 text

```python
from selenium import webdriver

browser = webdriver.Chrome()
url = 'https://www.zhihu.com/explore'
browser.get(url)
input = browser.find_element_by_class_name('zu-top-add-question')
print(input.text)
```

##### 3. 获取ID、位置、标签名、大小

```python
from selenium import webdriver

browser = webdriver.Chrome()
url = 'https://www.zhihu.com/explore'
browser.get(url)
input = browser.find_element_by_class_name('zu-top-add-question')
print(input.id)
print(input.location)
print(input.tag_name)
print(input.size)
```

#### 执行JavaScript

```python
from selenium import webdriver

browser = webdriver.Chrome()
browser.get('https://www.zhihu.com/explore')
browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')
browser.execute_script('alert("To Bottom")')
```

#### 操作表单元素：

1. 操作输入框：分为两步。第一步：找到这个元素。第二步：使用`send_keys(value)`，将数据填充进去。示例代码如下：

   ```python
    inputTag = driver.find_element_by_id('kw')
    inputTag.send_keys('python')
   ```

   使用`clear`方法可以清除输入框中的内容。示例代码如下：

   ```python
    inputTag.clear()
   ```

2. 操作checkbox：因为要选中`checkbox`标签，在网页中是通过鼠标点击的。因此想要选中`checkbox`标签，那么先选中这个标签，然后执行`click`事件。示例代码如下：

   ```python
    rememberTag = driver.find_element_by_name("rememberMe")
    rememberTag.click()
   ```

3. 选择select：select元素不能直接点击。因为点击后还需要选中元素。这时候selenium就专门为select标签提供了一个类`selenium.webdriver.support.ui.Select`。将获取到的元素当成参数传到这个类中，创建这个对象。以后就可以使用这个对象进行选择了。示例代码如下：

   ```python
    from selenium.webdriver.support.ui import Select
    # 选中这个标签，然后使用Select创建对象
    selectTag = Select(driver.find_element_by_name("jumpMenu"))
    # 根据索引选择
    selectTag.select_by_index(1)
    # 根据值选择
    selectTag.select_by_value("http://www.95yueba.com")
    # 根据可视的文本选择
    selectTag.select_by_visible_text("95秀客户端")
    # 取消选中所有选项
    selectTag.deselect_all()
   ```

4. 操作按钮：操作按钮有很多种方式。比如单击、右击、双击等。这里讲一个最常用的。就是点击。直接调用`click`函数就可以了。示例代码如下：

   ```python
    inputTag = driver.find_element_by_id('su')
    inputTag.click()
   ```

#### 行为链：

有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类`ActionChains`来完成。比如现在要将鼠标移动到某个元素上并执行点击事件。那么示例代码如下：

```python
from selenium.webdriver.common.action_chains import ActionChains

inputTag = driver.find_element_by_id('kw')
submitTag = driver.find_element_by_id('su')

actions = ActionChains(driver)
actions.move_to_element(inputTag)
actions.send_keys_to_element(inputTag,'python')
actions.move_to_element(submitTag)
actions.click(submitTag)
actions.perform()
```

还有更多的鼠标相关的操作。

- click_and_hold(element)：点击但不松开鼠标。
- context_click(element)：右键点击。
- double_click(element)：双击。 更多方法请参考：<http://selenium-python.readthedocs.io/api.html>

#### Cookie操作：

1. 获取所有的cookie:

   ```python
    for cookie in driver.get_cookies():
        print(cookie)
   ```

2. 根据cookie的key获取value：

   ```python
    value = driver.get_cookie(key)
   ```

3. 删除所有的cookie：

   ```python
    driver.delete_all_cookies()
   ```

4. 删除某个cookie：

   ```python
    driver.delete_cookie(key)
   ```

#### 页面等待：

现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。为了解决这个问题。所以 Selenium 提供了两种等待方式：一种是隐式等待、一种是显式等待。

1. 隐式等待：调用`driver.implicitly_wait`。那么在获取不可用的元素之前，会先等待10秒中的时间。示例代码如下：

   ```python
   driver = webdriver.Chrome(executable_path=driver_path)
   driver.implicitly_wait(10)
   # 请求网页
   driver.get("https://www.douban.com/")
   ```

2. 显示等待：显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用`selenium.webdriver.support.excepted_conditions`期望的条件和`selenium.webdriver.support.ui.WebDriverWait`来配合完成。示例代码如下：

   ```python
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
   
    driver = webdriver.Firefox()
    driver.get("http://somedomain/url_that_delays_loading")
    try:
        element = WebDriverWait(driver, 10).until(
           EC.presence_of_element_located((By.ID, "myDynamicElement")) # 注意这里是元组
          	# EC.url_to_be(目标url) # 当前的url和目标url是不是一样，一样就不等待。
           # EC.text_to_be_present_in_element_value((By.ID, text)) text是不是和这个byid的值一样
        )
    finally:
        driver.quit()
   ```

3. 一些其他的等待条件：

   - presence_of_element_located：某个元素已经加载完毕了。

   - presence_of_all_emement_located：网页中所有满足条件的元素都加载完毕了。

   - element_to_be_cliable：某个元素是可以点击了。

     更多条件请参考：<http://selenium-python.readthedocs.io/waits.html>

#### 切换页面：

有时候窗口中有很多子tab页面。这时候肯定是需要进行切换的。`selenium`提供了一个叫做`switch_to_window`来进行切换，具体切换到哪个页面，可以从`driver.window_handles`中找到，是一个列表，每一个窗口就是列表中的一个元素。示例代码如下：

```python
# 打开一个新的页面
self.driver.execute_script("window.open('"+url+"')") # 注意字符串上面的单引号
self.dirver.execute_script(f"window.open('{url}')")
# 切换到这个新的页面中
self.driver.switch_to.window(self.driver.window_handles[1])
```

虽然在窗口中切换到了新的页面，但是driver中还没有切换，如果想要在代码中切换到新的页面，并且做一些爬虫，那么应该使用driver.switch_to_window来切换到指定的窗口，从driver.window_handlers中取出具体第几个窗口，driver.window_handlers是一个列表，里面装的都是窗口句柄，他会按照打开页面的顺序来存储窗口的句柄。0991-8866837

#### 设置代理ip：

有时候频繁爬取一些网页。服务器发现你是爬虫后会封掉你的ip地址。这时候我们可以更改代理ip。更改代理ip，不同的浏览器有不同的实现方式。这里以`Chrome`浏览器为例来讲解：

```python
from selenium import webdriver

options = webdriver.ChromeOptions()
options.add_argument("--proxy-server=http://110.73.2.248:8123")
driver_path = r"D:\ProgramApp\chromedriver\chromedriver.exe"
driver = webdriver.Chrome(executable_path=driver_path,chrome_options=options)

driver.get('http://httpbin.org/ip')
```

#### `WebElement`元素：

`from selenium.webdriver.remote.webelement import WebElement`类是每个获取出来的元素的所属类。
有一些常用的属性：

1. get_attribute（属性名称）：这个标签的某个属性的值。
2. screentshot：获取当前页面的截图。这个方法只能在`driver`上使用。
   `driver`的对象类，也是继承自`WebElement`。
   更多请阅读相关源代码。

## 三、图形验证码识别技术：

阻碍我们爬虫的。有时候正是在登录或者请求一些数据时候的图形验证码。因此这里我们讲解一种能将图片翻译成文字的技术。将图片翻译成文字一般被成为光学文字识别（Optical Character Recognition），简写为`OCR`。实现`OCR`的库不是很多，特别是开源的。因为这块存在一定的技术壁垒（需要大量的数据、算法、机器学习、深度学习知识等），并且如果做好了具有很高的商业价值。因此开源的比较少。这里介绍一个比较优秀的图像识别开源库：Tesseract。

### Tesseract：

Tesseract是一个OCR库，目前由谷歌赞助。Tesseract是目前公认最优秀、最准确的开源OCR库。Tesseract具有很高的识别度，也具有很高的灵活性，他可以通过训练识别任何字体。

### 安装：

#### Windows系统：

在以下链接下载可执行文件，然后一顿点击下一步安装即可（放在不需要权限的纯英文路径下）：
<https://github.com/tesseract-ocr/>

#### Linux系统：

可以在以下链接下载源码自行编译。
<https://github.com/tesseract-ocr/tesseract/wiki/Compiling>
或者在`ubuntu`下通过以下命令进行安装：

```shell
sudo apt install tesseract-ocr
```

#### Mac系统：

用`Homebrew`即可方便安装：

```shell
brew install tesseract
```

#### 设置环境变量：

安装完成后，如果想要在命令行中使用`Tesseract`，那么应该设置环境变量。`Mac`和`Linux`在安装的时候就默认已经设置好了。在`Windows`下把`tesseract.exe`所在的路径添加到`PATH`环境变量中。

还有一个环境变量需要设置的是，要把训练的数据文件路径也放到环境变量中。
在环境变量中，添加一个`TESSDATA_PREFIX=C:\path_to_tesseractdata\teseractdata`。

### 在命令行中使用tesseract识别图像：

如果想要在`cmd`下能够使用`tesseract`命令，那么需要把`tesseract.exe`所在的目录放到`PATH`环境变量中。然后使用命令：`tesseract 图片路径 文件路径`。
示例：

```shell
tesseract a.png a
```

那么就会识别出`a.png`中的图片，并且把文字写入到`a.txt`中。如果不想写入文件直接想显示在终端，那么不要加文件名就可以了。

### 在代码中使用tesseract识别图像：

在`Python`代码中操作`tesseract`。需要安装一个库，叫做`pytesseract`。通过`pip`的方式即可安装：

```
pip install pytesseract
```

并且，需要读取图片，需要借助一个第三方库叫做`PIL`。通过`pip list`看下是否安装。如果没有安装，通过`pip`的方式安装：

```
pip install PIL
```

使用`pytesseract`将图片上的文字转换为文本文字的示例代码如下：

```python
# 导入pytesseract库
import pytesseract
# 导入Image库
from PIL import Image

# 指定tesseract.exe所在的路径
pytesseract.pytesseract.tesseract_cmd = r'D:\ProgramApp\TesseractOCR\tesseract.exe'

# 打开图片
image = Image.open("a.png")
# 调用image_to_string将图片转换为文字
text = pytesseract.image_to_string(image, lang="chi_sim") # lang=指定识别的语言
print(text)
```

### 用`pytesseract`处理拉勾网图形验证码：

```python
import pytesseract
from urllib import request
from PIL import Image
import time


pytesseract.pytesseract.tesseract_cmd = r"D:\ProgramApp\TesseractOCR\tesseract.exe"


while True:
    captchaUrl = "https://passport.lagou.com/vcode/create?from=register&refresh=1513081451891"
    request.urlretrieve(captchaUrl,'captcha.png')
    image = Image.open('captcha.png')
    text = pytesseract.image_to_string(image,lang='eng')
    print(text)
    time.sleep(2)
```

# 第五章 Scrapy框架

## 一、Scrapy框架架构

### Scrapy框架介绍：

写一个爬虫，需要做很多的事情。比如：发送网络请求、数据解析、数据存储、反反爬虫机制（更换ip代理、设置请求头等）、异步请求等。这些工作如果每次都要自己从零开始写的话，比较浪费时间。因此`Scrapy`把一些基础的东西封装好了，在他上面写爬虫可以变的更加的高效（爬取效率和开发效率）。因此真正在公司里，一些上了量的爬虫，都是使用`Scrapy`框架来解决。

### Scrapy架构图：

1. 流程图（1）：
   ![img](../assets/scrapy_all.png)
2. 流程图（2）：
   ![img](../assets/884863172-5985e0b48edf9.png)

### Scrapy框架模块功能：

1. `Scrapy Engine（引擎）`：`Scrapy`框架的核心部分。负责在`Spider`和`ItemPipeline`、`Downloader`、`Scheduler`中间通信、传递数据等。
2. `Spider（爬虫）`：发送需要爬取的链接给引擎，最后引擎把其他模块请求回来的数据再发送给爬虫，爬虫就去解析想要的数据。这个部分是我们开发者自己写的，因为要爬取哪些链接，页面中的哪些数据是我们需要的，都是由程序员自己决定。
3. `Scheduler（调度器）`：负责接收引擎发送过来的请求，并按照一定的方式进行排列和整理，负责调度请求的顺序等。
4. `Downloader（下载器）`：负责接收引擎传过来的下载请求，然后去网络上下载对应的数据再交还给引擎。
5. `Item Pipeline（管道）`：负责将`Spider（爬虫）`传递过来的数据进行保存。具体保存在哪里，应该看开发者自己的需求。
6. `Downloader Middlewares（下载中间件）`：可以扩展下载器和引擎之间通信功能的中间件。
7. `Spider Middlewares（Spider中间件）`：可以扩展引擎和爬虫之间通信功能的中间件。

Scrapy运行流程大概如下：

1. 引擎从调度器中取出一个链接(URL)用于接下来的抓取
2. 引擎把URL封装成一个请求(Request)传给下载器
3. 下载器把资源下载下来，并封装成应答包(Response)
4. 爬虫解析Response
5. 解析出实体（Item）,则交给实体管道进行进一步的处理
6. 解析出的是链接（URL）,则把URL交给调度器等待抓取

## Scrapy快速入门

### 安装和文档：

1. 安装：通过`pip install scrapy`即可安装。
2. Scrapy官方文档：<http://doc.scrapy.org/en/latest>
3. Scrapy中文文档：<http://scrapy-chs.readthedocs.io/zh_CN/latest/index.html>

> 注意：
>
> 1. 在`ubuntu`上安装`scrapy`之前，需要先安装以下依赖：
>    `sudo apt-get install python3-dev build-essential python3-pip libxml2-dev libxslt1-dev zlib1g-dev libffi-dev libssl-dev`，然后再通过`pip install scrapy`安装。
> 2. 如果在`windows`系统下，提示这个错误`ModuleNotFoundError: No module named 'win32api'`，那么使用以下命令可以解决：`pip install pypiwin32`。

### 快速入门：

#### 创建项目：

要使用`Scrapy`框架创建项目，需要通过命令来创建。首先进入到你想把这个项目存放的目录。然后使用以下命令创建：

```shell
scrapy startproject [项目名称] 
```

#### 目录结构介绍：

![img](/Users/mengjuncheng/Desktop/爬虫/media/屏幕快照 2019-03-27 上午11.26.54.png)
以下介绍下主要文件的作用：

1. items.py：用来存放爬虫爬取下来数据的模型。
2. middlewares.py：用来存放各种中间件的文件。
3. pipelines.py：用来将`items`的模型存储到本地磁盘中。
4. settings.py：本爬虫的一些配置信息（比如请求头、多久发送一次请求、ip代理池等）。
5. scrapy.cfg：项目的配置文件。
6. spiders包：以后所有的爬虫，都是存放到这个里面。

### 使用Scrapy框架爬取糗事百科段子：

#### 使用命令创建一个爬虫：

```shell
scrapy gensipder qsbk_spider "qiushibaike.com" # 注意要切到项目目录里，再就是名子不能和项目重名
```

创建了一个名字叫做`qsb_spider`的爬虫，并且能爬取的网页只会限制在`qiushibaike.com`这个域名下。

#### 爬虫代码解析：

```python
import scrapy

class QsbkSpider(scrapy.Spider):
    name = 'qsbk'
    allowed_domains = ['qiushibaike.com']
    start_urls = ['http://qiushibaike.com/']

    def parse(self, response):
        pass
```

其实这些代码我们完全可以自己手动去写，而不用命令。只不过是不用命令，自己写这些代码比较麻烦。
要创建一个Spider，那么必须自定义一个类，继承自`scrapy.Spider`，然后在这个类中定义三个属性和一个方法。

1. name：这个爬虫的名字，名字必须是唯一的。
2. allow_domains：允许的域名。爬虫只会爬取这个域名下的网页，其他不是这个域名下的网页会被自动忽略。
3. start_urls：爬虫从这个变量中的url开始。
4. parse：引擎会把下载器下载回来的数据扔给爬虫解析，爬虫再把数据传给这个`parse`方法。这个是个固定的写法。这个方法的作用有两个，第一个是提取想要的数据。第二个是生成下一个请求的url。

#### 修改`settings.py`代码：

在做一个爬虫之前，一定要记得修改`setttings.py`中的设置。两个地方是强烈建议设置的。

1. `ROBOTSTXT_OBEY`设置为False。默认是True。即遵守机器协议，那么在爬虫的时候，scrapy首先去找robots.txt文件，如果没有找到。则直接停止爬取。
2. `DEFAULT_REQUEST_HEADERS`添加`User-Agent`。这个也是告诉服务器，我这个请求是一个正常的请求，不是一个爬虫。

#### 完成的爬虫代码：

1. 爬虫部分代码：

   ```python
    import scrapy
    from abcspider.items import QsbkItem
   
    class QsbkSpider(scrapy.Spider):
        name = 'qsbk'
        allowed_domains = ['qiushibaike.com']
        start_urls = ['https://www.qiushibaike.com/text/']
   		 base_domain = "https://www.qiushibaike.com"
        def parse(self, response):
         '''
        1、 response是from scrapy.http.response.html import HtmlResponse类的对象，可以执行xpath,和css来提取数据。
         2、提取出来的数据是一个selector或者是一个SelectorList对象，如果想要获取其中的字符串，那么应该
         执行getall或者get方法
         3、getall方法:获取Selector中所有的文本，返回的是一个列表
         4、get方法：获取的是selector中的第一个文本，返回的是一个str类型
         5、如果数据解析回来，要传给pipline处理，那么可以使用yield来执行(或者数据组成一个列表，return出去也行)
         6、item:建议在items.py中定义好模型，不要使用字典
         7、pipline这个是专门用来保存数据的，其中有三个方法是会经常用的
         open_spider(self,spider) 当爬虫被打开的时候执行
         process_item(self, item, spider)当爬虫有item传过来的时候会被调用
         close_spider(self, spider)当爬虫关闭的时候会调用
         要激活pipline，应该在settings中，设置ITEM_PIPELINES。
         '''
            outerbox = response.xpath("//div[@id='content-left']/div")
            items = []
            for box in outerbox:
                author = box.xpath(".//div[contains(@class,'author')]//h2/text()").extract_first().strip()
                content = box.xpath(".//div[@class='content']/span/text()").extract_first().strip()
                item = QsbkItem()
                item["author"] = author
                item["content"] = content
                items.append(item)
                yield item
            # return items # 注意这个return就直接退出了爬虫，而应该改成yield
           # 找到下一页标签里的url
           next_url = respone.xpath("//ul[@class='pagination]//li[last()]/a/@href").get()
           if not next_url:
             return
           else:
             yield scrapy.Request(self.base_domain+next_url, callback=self.parse)
         
   ```

   为了避免过快导致的封Ip，在settings.py中设置`DOWNLOAD_DELAY = 3`的值单位秒

2. items.py部分代码：

   ```python
    import scrapy
    class QsbkItem(scrapy.Item):
        author = scrapy.Field()
        content = scrapy.Field()
   ```

3. pipeline部分代码：

   ```python
    import json
    '''
    JsonItemExporter这个是每次把数据添加到内存中，每一项做为一个字典，组成一个列表，最后统一写到硬盘中，
    好处是存储的是一个满足json规则的数据，坏处是如果数据量比较大，那么比较耗内存
    from scrapy.exporters import JsonItemExporter
    class QsbkPipeline:
    		def __init__(self):
    			self.f = open('duanzi.json','wb') # 必须是bytes二进制类型
    			self.exporter = JsonItemExporter(self, f, ensure_ascii=False,encoding='utf8')
    			self.exporter.start_exporting()
    		def process_item(self, item, spider):
    			self.exporter.export_item(item)
    			return item
    		def close_spider(self, spider):
    			self.exporter.finish_exporting()
    			self.f.close()
    '''
   '''
   JsonLineItemExporter这个是每次调用export_item的时候就把这个item做为一个字典存储一行，整个文件不是一个
   满足json格式的文件，好处是每次处理数据就直接存储到了硬盘中，这样不会耗内存
   还有其他的存储方式都在scrapy.exporters包下
   from scrapy.exporters import JsonLineItemExporter
    class QsbkPipeline:
    		def __init__(self):
    			self.f = open('duanzi.json','wb') # 必须是bytes二进制类型
    			self.exporter = JsonLineItemExporter(self, f, ensure_ascii=False,encoding='utf8')
    			
    		def process_item(self, item, spider):
    			self.exporter.export_item(item)
    			return item
    			
    		def close_spider(self, spider):
    			self.f.close()
   '''
    class AbcspiderPipeline(object):
        def __init__(self):
   
           self.items = []
           # self.f = open('duanzi.json', 'w', encoding='utf8')
        def open_spider(self, spider):
         '''
         爬虫运行就会去调用这个函数，比如打开一个存储的文件，用来存储后续的内容，或者也可以在构造函数中打开
         '''
         	pass
   
        def process_item(self, item, spider):
         '''
         爬虫如果yield了一些数据，就会调用这个函数
         '''
            self.items.append(dict(item))
            print("="*40)
            return item
   
        def close_spider(self,spider):
         '''
         爬虫完成了后调用
         '''
            with open('qsbk.json','w',encoding='utf-8') as fp:
                json.dump(self.items,fp,ensure_ascii=False)
   ```

然后在settings里取消如下的注释，让其自动运行

```python
ITEM_PIPELINES = {
    'qsbk.pipelines.QsbkPipeline': 300, # 如果有多个pipelines，后面的值代表执行的优先级，值越小，优先级越高。
} # 注意不取消注释，是不会pipelines的，也就不会写入到文件
```



#### 运行scrapy项目：

运行scrapy项目。需要在终端，进入项目所在的路径，然后`scrapy crawl [爬虫名字]`即可运行指定的爬虫。如果不想每次都在命令行中运行，那么可以把这个命令写在一个文件中。以后就在pycharm中执行运行这个文件就可以了。比如现在新创建一个文件叫做`start.py`，然后在这个文件中填入以下代码：

```python
from scrapy import cmdline

cmdline.execute("scrapy crawl qsbk_spider".split())
```

## 二、CrawlSpider

在上一个糗事百科的爬虫案例中。我们是自己在解析完整个页面后获取下一页的url，然后重新发送一个请求。有时候我们想要这样做，只要满足某个条件的url，都给我进行爬取。那么这时候我们就可以通过`CrawlSpider`来帮我们完成了。`CrawlSpider`继承自`Spider`，只不过是在之前的基础之上增加了新的功能，可以定义爬取的url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动的`yield Request`。

### CrawlSpider爬虫：

### 创建CrawlSpider爬虫：

之前创建爬虫的方式是通过`scrapy genspider [爬虫名字] [域名]`的方式创建的。如果想要创建`CrawlSpider`爬虫，那么应该通过以下命令创建：

```python
scrapy genspider -t crawl [爬虫名字] [域名]
```

### LinkExtractors链接提取器：

使用`LinkExtractors`可以不用程序员自己提取想要的url，然后发送请求。这些工作都可以交给`LinkExtractors`，他会在所有爬的页面中找到满足规则的`url`，实现自动的爬取。以下对`LinkExtractors`类做一个简单的介绍：

```python
class scrapy.linkextractors.LinkExtractor(
    allow = (),
    deny = (),
    allow_domains = (),
    deny_domains = (),
    deny_extensions = None,
    restrict_xpaths = (),
    tags = ('a','area'),
    attrs = ('href'),
    canonicalize = True,
    unique = True,
    process_value = None
)
```

主要参数讲解：

- allow：允许的url。所有满足这个正则表达式的url都会被提取。要能够限制在我们想要的url上面，不要跟其他的url产生相同的正则表达式即可
- deny：禁止的url。所有满足这个正则表达式的url都不会被提取。
- allow_domains：允许的域名。只有在这个里面指定的域名的url才会被提取。
- deny_domains：禁止的域名。所有在这个里面指定的域名的url都不会被提取。
- restrict_xpaths：严格的xpath。和allow共同过滤链接。

### Rule规则类：

定义爬虫的规则类。以下对这个类做一个简单的介绍：

```python
class scrapy.spiders.Rule(
    link_extractor, 
    callback = None, 
    cb_kwargs = None, 
    follow = None, 
    process_links = None, 
    process_request = None
)
```

主要参数讲解：

- link_extractor：一个`LinkExtractor`对象，用于定义爬取规则。
- callback：满足这个规则的url，应该要执行哪个回调函数。因为`CrawlSpider`使用了`parse`作为回调函数，因此不要覆盖`parse`作为回调函数自己的回调函数。只是为了获取更多的url，并不是需要里面的数据，那么可以不指定callback。如果想要获取url对应页面中的数据，那么就需要指定一个callback
- follow：指定根据该规则从response中提取的链接是否需要跟进。什么情况下使用follow，如果在爬取页面的时候，需要将满足当前条件的url再进行跟进，那么就设置为True,否则设置为False
- process_links：从link_extractor中获取到链接后会传递给这个函数，用来过滤不需要爬取的链接。

### 微信小程序社区CrawlSpider案例

1. 爬虫部分代码

```python
from scrapy.spiders import CrawlSpider, Rule
from wxapp.items import WxappItem

class WxappSpiderSpider(CrawlSpider):
    name = 'wxapp_spider'
    allowed_domains = ['wxapp-union.com']
    start_urls = ['http://www.wxapp-union.com/portal.php?mod=list&catid=2&page=1']

    rules = (
        Rule(LinkExtractor(allow=r'.+mod=list&catid=2&page=\d'),
             callback='parse_item', follow=True), # follow True 表示跟进,同一页中有相同规则的url也会爬取，这里不需要clallback，
        # 因为需要的数据在详情页面里
        Rule(LinkExtractor(allow=r'.+article\-\d+\-\d+\.html'), callback='parse_detail', follow=False)
    )

    def parse_detail(self, response):
        title = response.xpath("//h1[@class='ph']/text()").get()
        author_p = response.xpath("//p[@class='authors']")
        author = author_p.xpath(".//a/text()").get()
        pub_time = author_p.xpath(".//span/text()").get()
        article_content = response.xpath("//td[@id='article_content']//text()").getall()
        article_content = ''.join(article_content).strip()
        item = WxappItem(title=title, author=author, pub_time=pub_time, content=article_content)
        yield item
```

2. items.py部分代码

```python
import scrapy

class WxappItem(scrapy.Item):
    title = scrapy.Field()
    author = scrapy.Field()
    pub_time = scrapy.Field()
    content = scrapy.Field()
```

3. pipeline部分代码：

```python
from scrapy.exporters import JsonLinesItemExporter

class WxappPipeline(object):

    def __init__(self):
        self.f = open('wx.json', 'wb')
        self.exporter = JsonLinesItemExporter(self.f, ensure_ascii=False, encoding='utf8')


    def process_item(self, item, spider):
        self.exporter.export_item(item)
        return item

    def close_spider(self, spider):
        self.f.close()
```

## 三、Scrapy Shell

我们想要在爬虫中使用xpath、beautifulsoup、正则表达式、css选择器等来提取想要的数据。但是因为`scrapy`是一个比较重的框架。每次运行起来都要等待一段时间。因此要去验证我们写的提取规则是否正确，是一个比较麻烦的事情。因此`Scrapy`提供了一个shell，用来方便的测试规则。当然也不仅仅局限于这一个功能。

### 打开Scrapy Shell：

打开cmd终端，进入到`Scrapy`项目所在的目录，然后进入到`scrapy`框架所在的虚拟环境中，输入命令`scrapy shell [链接]`。就会进入到scrapy的shell环境中。在这个环境中，你可以跟在爬虫的`parse`方法中一样使用了。 

![屏幕快照 2019-03-27 下午7.04.26](/Users/mengjuncheng/Desktop/爬虫/media/屏幕快照 2019-03-27 下午7.04.26.png)

![屏幕快照 2019-03-27 下午7.08.03](/Users/mengjuncheng/Desktop/爬虫/media/屏幕快照 2019-03-27 下午7.08.03.png)

也可以导入第三方的库

![屏幕快照 2019-03-27 下午7.19.30](/Users/mengjuncheng/Desktop/爬虫/media/屏幕快照 2019-03-27 下午7.19.30.png)

1. 可以方便我们做一些数据提取的测试代码。
2. 如果想要执行scrapy命令，需要先进入到scrapy所在的环境中
3. 如果想要读取某个项目的配置信息，那么应该先进入到这个项目中再执行`scrapy shell http://xxxx`

## 四、Request和Response对象

```python
class Request(object_ref):

    def __init__(self, url, callback=None, method='GET', headers=None, body=None,
                 cookies=None, meta=None, encoding='utf-8', priority=0,
                 dont_filter=False, errback=None, flags=None):

        self._encoding = encoding  # this one has to be set first
        self.method = str(method).upper()
        self._set_url(url)
        self._set_body(body)
        assert isinstance(priority, int), "Request priority not an integer: %r" % priority
        self.priority = priority

        if callback is not None and not callable(callback):
            raise TypeError('callback must be a callable, got %s' % type(callback).__name__)
        if errback is not None and not callable(errback):
            raise TypeError('errback must be a callable, got %s' % type(errback).__name__)
        assert callback or not errback, "Cannot use errback without a callback"
        self.callback = callback
        self.errback = errback

        self.cookies = cookies or {}
        self.headers = Headers(headers or {}, encoding=encoding)
        self.dont_filter = dont_filter

        self._meta = dict(meta) if meta else None
        self.flags = [] if flags is None else list(flags)
```



`from scrapy.http import Request`

Request对象在我们写爬虫，爬取一页数据需要重新发送一个请求的时候调用，这个类需要传一些参数，其中比较常用的参数有：

1. url ：这个request对象发送请求的url

2. callback：在下载器完成相应的数据后执行的回调函数 。

3. method：请求的方法，默认为GET方法，可以设置为其他的方法。

4. headers：请求头，对于一些固定的设置，放在settings.py中指定就可以了，对于那些非固定的，可以在发送请求的时候指定。

5. meta：比较常用，用于参不同请求之间传递数据用的。

6. encoding：编码，默认utf8，使用默认就可以了

7. dot_filter：表示不由调度器过滤，在执行多次重复的请求的时候用的比较多。比如验证码错误后，再发一次

   ```python
   def parse(self, response):
     user_agent = json.loads(response.text)['user-agent']
     print(user_agent)
     yield scrapy.Request(self.start_urls[0], dont_filter=True) # scrapy 有去重的功能，同一个url不会再次请求，加上dot_filter就可以重新让调度器再次请求
   ```

8. errback：在发生错误的时候执行的函数。

## Response对象

response对象一般由scrapy给你自动构建的。因此开发者不需要关心如何创建Response对象，而是如何使用，Response对象有很多属性，可以用来提取数据的。主要有以下属性。

`from scrapy.http import Response`

```python
"""
This module implements the Response class which is used to represent HTTP
responses in Scrapy.

See documentation in docs/topics/request-response.rst
"""
from six.moves.urllib.parse import urljoin

from scrapy.http.request import Request
from scrapy.http.headers import Headers
from scrapy.link import Link
from scrapy.utils.trackref import object_ref
from scrapy.http.common import obsolete_setter
from scrapy.exceptions import NotSupported


class Response(object_ref):

    def __init__(self, url, status=200, headers=None, body=b'', flags=None, request=None):
        self.headers = Headers(headers or {})
        self.status = int(status)
        self._set_body(body)
        self._set_url(url)
        self.request = request
        self.flags = [] if flags is None else list(flags)

    @property
    def meta(self):
        try:
            return self.request.meta
        except AttributeError:
            raise AttributeError(
                "Response.meta not available, this response "
                "is not tied to any request"
            )

    def _get_url(self):
        return self._url

    def _set_url(self, url):
        if isinstance(url, str):
            self._url = url
        else:
            raise TypeError('%s url must be str, got %s:' % (type(self).__name__,
                type(url).__name__))

    url = property(_get_url, obsolete_setter(_set_url, 'url'))

    def _get_body(self):
        return self._body

    def _set_body(self, body):
        if body is None:
            self._body = b''
        elif not isinstance(body, bytes):
            raise TypeError(
                "Response body must be bytes. "
                "If you want to pass unicode body use TextResponse "
                "or HtmlResponse.")
        else:
            self._body = body

    body = property(_get_body, obsolete_setter(_set_body, 'body'))

    def __str__(self):
        return "<%d %s>" % (self.status, self.url)

    __repr__ = __str__

    def copy(self):
        """Return a copy of this Response"""
        return self.replace()

    def replace(self, *args, **kwargs):
        """Create a new Response with the same attributes except for those
        given new values.
        """
        for x in ['url', 'status', 'headers', 'body', 'request', 'flags']:
            kwargs.setdefault(x, getattr(self, x))
        cls = kwargs.pop('cls', self.__class__)
        return cls(*args, **kwargs)

    def urljoin(self, url):
        """Join this Response's url with a possible relative url to form an
        absolute interpretation of the latter."""
        return urljoin(self.url, url)

    @property
    def text(self):
        """For subclasses of TextResponse, this will return the body
        as text (unicode object in Python 2 and str in Python 3)
        """
        raise AttributeError("Response content isn't text")

    def css(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
        raise NotSupported("Response content isn't text")

    def xpath(self, *a, **kw):
        """Shortcut method implemented only by responses whose content
        is text (subclasses of TextResponse).
        """
        raise NotSupported("Response content isn't text")

    def follow(self, url, callback=None, method='GET', headers=None, body=None,
               cookies=None, meta=None, encoding='utf-8', priority=0,
               dont_filter=False, errback=None):
        # type: (...) -> Request
        """
        Return a :class:`~.Request` instance to follow a link ``url``.
        It accepts the same arguments as ``Request.__init__`` method,
        but ``url`` can be a relative URL or a ``scrapy.link.Link`` object,
        not only an absolute URL.
        
        :class:`~.TextResponse` provides a :meth:`~.TextResponse.follow` 
        method which supports selectors in addition to absolute/relative URLs
        and Link objects.
        """
        if isinstance(url, Link):
            url = url.url
        elif url is None:
            raise ValueError("url can't be None")
        url = self.urljoin(url)
        return Request(url, callback,
                       method=method,
                       headers=headers,
                       body=body,
                       cookies=cookies,
                       meta=meta,
                       encoding=encoding,
                       priority=priority,
                       dont_filter=dont_filter,
                       errback=errback)

```

1. meta：从其他请求传过来的meta属性，可以用来保持多个请求之间的数据连接。
2. encoding：返回当前字符串编码和格式
3. text：将返回的数据作为unicode字符串返回。
4. body：将返回来的数据做为bytes字符串返回
5. xpath：xpath选择器
6. css：css选择器。

### 发送POST请求

有时候我们想要在请求数据的时候发送post请求，那么这时候需要使用Request的子类FormRequest来实现，如果想要在爬虫一开始的时候就发送POST请求，那么就需要在爬虫类`scrapy.Spider`中重写`start_requests(self)`方法，并且不再调用`start_urls`里的url。

```python
    def start_requests(self):
        cls = self.__class__
        if method_is_overridden(cls, Spider, 'make_requests_from_url'):
            warnings.warn(
                "Spider.make_requests_from_url method is deprecated; it "
                "won't be called in future Scrapy releases. Please "
                "override Spider.start_requests method instead (see %s.%s)." % (
                    cls.__module__, cls.__name__
                ),
            )
            for url in self.start_urls:
                yield self.make_requests_from_url(url)
        else:
            for url in self.start_urls:
                yield Request(url, dont_filter=True) # 这里是循环start_urls里的每个url,默认发送的是GET请求
```



### 登陆人人网

```python
import scrapy
class RenrenSpider(scrapy.Spider):
    name = 'renren'
    allowed_domains = ['renren.com']
    start_urls = ['http://renren.com/']

    def start_requests(self):
        url = "http://www.renren.com/SysHome.do"
        data = {'email':'189xxxxxx', 'password':'fsfsfwwrw'}
        request = scrapy.FormRequest(url, formdata=data, callback=self.parse_page)
        yield request

    def parse_page(self, response):
        # with open('ren.html', 'w', encoding='utf8') as f:
        #     f.write(response.text)
        request = scrapy.Request(
            url="http://www.renren.com/880151247/profile", callback=self.parse_profile
        )
        yield request
        
    def parse_profile(self, response):
        with open('dp.html', 'w', encoding='utf8') as f:
            f.write(response.text)
```

1. 如果发送post请求，推荐使用`scrapy.FormRequest`方法，可以方便的指定表单数据。`yield scrapy.FormRequest(url, formdata, callback)`
2. 如果想在爬虫一开始的时候，就发送post请求，那么应该重写`start_requests`方法， 在这个方法中发送post请求。

```python
class mySpider(scrapy.Spider):
    # start_urls = ["http://www.example.com/"]

    def start_requests(self):
        url = 'http://www.renren.com/PLogin.do'

        # FormRequest 是Scrapy发送POST请求的方法
        yield scrapy.FormRequest(
            url = url,
            formdata = {"email" : "xxx", "password" : "xxxxx"},
            callback = self.parse_page
        )
    def parse_page(self, response):
        # do something
```

## 五、下载文件和图片

scrapy为下载item 中包含的文件(比如在爬取到产品时，同时也想保存对应的图片）提供了一个可重用的item pipelines。这些pipeline有些方法和结构(我们称之为modia pipeline)。一般来说你会使用files pipeline或者images pipeline。

### 为什么要选择使用sscrapy内置的下载文件的方法

1. 避免重新下载最近已经下载过的数据
2. 可以方便的指定文件存储的路径
3. 可以将下载的图片转化成能用的格式。比如png或者jpg
4. 可以方便的生成缩略图
5. 可以方便的检测图片的宽和高，确保他们满足最小限制。
6. 异步下载，效率非常高。

### 下载文件的Files Pipeline

当使用Files Pipeline下载文件的时候，按照以下步骤来完成：

1. 定义好一个item，然后在这个item中定义两个属性，分别为file_urls以及files。file_urls是用来存储需要下载的图片的url链接，需要给一个列表。
2. 当文件下载完成后，会把文件下载的相关信息存储到item的files属性中，比如下载的路径，下载的url和文件的检验码等。
3. 在配置文件settings.py配置FILES_STORE，这个配置是用来设置文件下载下来的路径。
4. 启动pipeline:在ITEM_PIPELINES中设置scrapy.pipeline.files.FilesPipeLine:1

### 下载图片的Images Pipeline

当使用Images Pipeline 下载文件的时候，按照以下步骤来完成：

1. 定义好一个item,你有看到在这个item中定义两个属性，分别为image_url以及images。image_urls是用来存储需要下载的图片的url连接，需要给一个列表。
2. 当文件下载完成后，会把文件下载的相关信息存储到item的images属性中。比如下载路径，下载的url和图片的校验码等。
3. 在配置文件settings.py中配置IMAGES_STORE，这个配置是用来设置图片下载下来的路径。
4. 启动pipeline，在ITEM_PIPELINTS中设置scrapy.pipelines.images.ImagesPipeline:1

### scrapy的常用ImagesPipeline重写实现

```python
class ImageItem(scrapy.Item):
    image_urls = scrapy.Field()
    images = scrapy.Field()
```

**重写ImagesPipeline**

```python
import hashlib  # 下载图片地址哈希命名
from scrapy.http import Request  # 请求下载图片管道用
from scrapy.pipelines.images import ImagesPipeline
from scrapy.utils.python import to_bytes  # 下载图片用
from .items import WebSiteNewsItem

class DownloadImagesPipeline(ImagesPipeline):  # 下载图片的管道，

    def get_media_requests(self, item, info):  # 请求获取图片
        '''ImagePipeline根据image_urls中指定的url进行爬取，若不用默认字段则在这里重写
           可以通过get_media_requests为每个url生成一个Request
           get_media_requests函数返回示例如下：
           [(True,
               {’checksum’: ’2b00042f7481c7b056c4b410d28f33cf’,
               ’path’: ’full/7d97e98f8af710c7e7fe703abc8f639e0ee507c4.jpg’,
               ’url’: ’http://www.example.com/images/product1.jpg’}),
           (True,
               {’checksum’: ’b9628c4ab9b595f72f280b90c4fd093d’,
               ’path’: ’full/1ca5879492b8fd606df1964ea3c1e2f4520f076f.jpg’,
               ’url’: ’http://www.example.com/images/product2.jpg’}),
           (False,
               Failure(...))]
        '''
        if isinstance(item, WebSiteNewsItem) and item.get('image_list') and item.get('publish_date'):
            for image_url in item['image_list'].split(u','):  # 从item的image_list字段中 分割出图片链接地址
                yield Request(image_url.replace('\\', '/'), meta={'publish_date': info.spider.publish_date},
                              headers={'Referer': item['url']})
                # 链接中"\\"替换为"/" 向图片地址发出请求

    def item_completed(self, results, item, info):
        '''所有图片处理完毕后（不管下载成功或失败），会调用item_completed进行处理
           results是一个list 第一个为图片下载状态,
           get_media_requests在图片下载完毕后，处理结果会以二元组的方式返回给item_completed()函数的
           results，图片下载状态定义如下：
               (success, image_info_or_failure)  
               success表示图片是否下载成功；image_info_or_failure是一个字典
        '''
        image_paths = [info.get('path', None) for success, info in results if success and info]
        if not image_paths:
            return item
        if isinstance(item, WebSiteNewsItem):
            item['image_list'] = u','.join(image_paths)
        return item

    def file_path(self, request, response=None, info=None):
        image_guid = hashlib.sha1(to_bytes(request.url)).hexdigest()  # 对请求地址取哈希值
        return u'%s/%s/%s.jpg' % (

            request.meta['publish_date'].strftime('%Y-%m/%Y%m%d'),  # 这里构建了两级地址
            info.spider.zh_name, image_guid)
        # 发表日期，爬虫中文名，哈希值拼成路径，存储图片的路径类似于：2018-10/20181017/爬虫中文名/图片哈希值
```

**配置好settings**

```python
import os

import os
ITEM_PIPELINES = {
    #自定义的pipelines
    'articleSpider.pipelines.MyImagesPipeline': 300,
}
#自定义存储imageurl的字段,item["front_image_url"]
IMAGES_URL_FILED = "front_image_url"
#工程根目录
project_dir = os.path.dirname(__file__)
#下载图片存储位置
IMAGES_STORE = os.path.join(project_dir, 'images')

# 其他参数
# 该字段的值为XxxItem中定义的存储图片链接的image_urls字段
# IMAGES_URLS_FIELD='image_urls'
# 该字段的值为XxxItem中定义的存储图片信息的images字段
# IMAGES_RESULT_FIELD='images'
# 生成缩略图(可选)
'''
IMAGES_THUMBS = {
    'small': (50, 50),
    'big': (270, 270),
}
'''
# 过期时间,单位:天(可选)
# IMAGES_EXPIRES = 120
# 过滤小图片(可选)
# IMAGES_MIN_HEIGHT = 110
# IMAGES_MIN_WIDTH = 110
# 是否允许重定向(可选)
# MEDIA_ALLOW_REDIRECTS = True
```

### 使用mysql存储数据

```python
pipelines.py

import pymysql
class JianshuSpiderPipeline(object):
  def __init__(self):
    dbparams = {
      'host': '127.0.0.1',
      'port': '3306',
      'user': 'root',
      'password': 'root',
      'database': 'jianshu',
      'charset': 'utf8'
    }
    self.conn = Pymysql.connect(**dbparams)
   	self.cursor = self.conn.curesor()
    self._sql = None
  def process_item(self, item, spider):
    self.cursor.execute(self.sql,(item['title'], item['content'], item['author'], item['avatar'], item['pub_time'], item['origin_url'], item['article_id']))
    self.conn.commit()
   @property
 	def sql(self):
    if not self._sql:
      self._sql = '''
      insert into article(id,title, content, author, avatar,pub_itme, origin_url, article_id) value(null, %s,%s, %s,%s, %s,%s, %s) 
      '''
      return self._sql
   	return self._sql
```

数据库的异步存储

```python
import pymysql
from twisted.enterprise import adbapi
from pymysql import cursors
class JianshuTwistedPipeline:
  def __init__(self):
     dbparams = {
      'host': '127.0.0.1',
      'port': '3306',
      'user': 'root',
      'password': 'root',
      'database': 'jianshu',
      'charset': 'utf8',
      'cursorclass': cursors.DictCursor
    }
    	self.dbpool = adb.api.ConnectionPool('pymysql', **dbparams) # 创建连接池
    	self._sql = None
  @property
 	def sql(self):
    if not self._sql:
      self._sql = '''
      insert into article(id,title, content, author, avatar,pub_itme, origin_url, article_id) value(null, %s,%s, %s,%s, %s,%s, %s) 
      '''
      return self._sql
   	return self._sql
  def process_item(self, item, spider):
    defer = self.dbpool.runInteraction(self.insert_item, item)
    def.addErrback(self.handle_error, item, spider)
  def insert_item(self, cursor, item):
    cursor.execurte(self.sql, (item['title'], item['content'], item['author'], item['avatar'], item['pub_time'], item['origin_url'], item['article_id']))
  def handle_error(self.error, item, spider)
    print(error)
    
 在settings.py中ITEM_PIPELINES中添加
ITEM_PIPELINES = {
   'douban.pipelines.JianshuTwistedPipeline': 300,
}
```



## 六、下载器中间件(Downloader Middlewares)

下载器中间件是引擎和下载器之间通信的中间件，在这个中间件中我们可以设置代理 、更换请求头等来达到反反爬虫的上的。要写下载器中间件，可以在下载器中实现两个方法，一个是`process_request(self,request, spider)`，这个方法是在请求发送之前会执行，还有一个是`process_response(self,request, response, spider)`，这个方法是数据下载到引擎之前执行。

### process_request(self, request, spider)

这个方法是下载器在发送请求之前会执行的，一般可以在这个里面设置随机代理ip等

1. 参数

   * request：发送请求的request对象

   * spider：发送请求的spider对象

2. 返回值：

   * 返回None：如果返回None， Scrapy等继续处理该request，执行其他中间件中的相应方法，直到合适的下载器处理函数被调用。
   * 返回Response对象：Scrapy将不会调用任何其他的`process_request`方法，将直接返回这个`response`对象。已经激活中间件的`process_response()`方法则会在每个response返回时被调用。
   * 返回Request对象：不再使用之前的request对象去下载数据，而是根据现在返回的request对象返回数据。
   * 如果 这个方法中抛出了异常，则会调用`process_exception`方法

### process_response(self, request, response, spider)

这个是下载器下载的数据到引擎中间会执行的方法：

1. 参数
   * request：request对象
   * response：被处理的response对象
   * spider：spider对象
2. 返回值：
   * 返回Response对象：会将这个新的response对象传给其他的中间件，最终传给爬虫
   * 返回Requst对象：下载器链接被切断，返回的request会重新被下载器调度下载
   * 如果抛出一个异常，那么调用request的errback方法，如果没有指定这个方法，那么会抛出一个异常

### 随机请求头中间件：

爬虫在频繁访问一个页面的时候，这个请求头如果一直保持一致，那么很容易被服务器发现，从而禁止这个请求头的访问，因此我们要在访问这个页面之前随机的更改请求头，这样才可以避免爬虫被抓，随机更改请求头，可以在下载中间件中实现，在请求发送给服务器之前，随机的选择一个请求头，这样就可以避免总使用一个请求头了。

1. 定义一个存放请求头的列表，并从中随机获取请求头：

   在`middlewares.py`中添加

   ```python
   from Douban.settings import USER_AGENT_LIST
   import random
   
   class RandomUserAgent(object):
       # 定义一个中间键类
       # 用户代理
       def process_request(self, request, spider):
           # 检验一下请求头
           # print(request.headers['User-Agent'])
           # 获取一个请求头
           ua = random.choice(USER_AGENT_LIST)
           # 设置请求头代理
           request.headers['User-Agent'] = ua
   ```

   settings.py设置

   ```python
   DOWNLOADER_MIDDLEWARES = {
      # 'Douban.middlewares.MyCustomDownloaderMiddleware': 543,
      #注册请求头用户代理
      'Douban.middlewares.RandomUserAgent': 543,
   }
   #自定义请求头，用户代理(自定)
   USER_AGENT_LIST =[
       "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; HCI0449; .NET CLR 1.0.3705) ",
       "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; i-NavFourF; .NET CLR 1.1.4322) ",
       "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; Maxthon; "
   ]
   ```

请求头(用户)代理 随机）
定一个中间键类，重写process_request(self,request, spider)方法,
对request的处理进行相应的配置，并把配置好以后，
并把响应的类注册到setting文件中。

参数[request，spider],并检验请求头。Print(request.headers[‘User-Agent’])。
需要在setting中DOWNLOADER_MIDDLEWARES(自定义中间键)配置

查看用户是用哪个代理请求头，在爬虫中`parse_item方法下这里print(response.request.headers[‘User-Agent’]`

2. 通过`fake_useragent`模块随机获取请求头

`pip install fake-useragent`

```python
from fake_useragent import UserAgent
class UserAgentDownloadMiddleware(object):
    def process_request(self,request,spider):
        user_agent = UserAgent().random
        request.headers['User-Agent'] = user_agent
```

settings.py设置中注意中间件

### 代理池中间件

代理的平台：

西刺免费代理  芝麻代理、 太阳代理 、 快代理、 讯代理、 蚂蚁代理

- 西刺免费代理IP：<http://www.xicidaili.com/>
- 快代理：<http://www.kuaidaili.com/>
- 代理云：<http://www.dailiyun.com/>

```python
rom scrapy import signals
import random
import base64
from Douban.settings import PROXY_LIST

class RandomProxy(object):
    def process_request(self, request, spider):
        # 随机取出一个代理ip
        proxy = random.choice(PROXY_LIST)

        # 判断是否为人民币玩家
        if 'user_passwd' in proxy:
            #把账号密码转换为b64编码格式(字符串先变成bytes类型）必须字符串转为bytes
            b64_data = base64.b64encode(proxy['user_passwd'].encode())
            # 设置账号密码认证                     认证方式   编码之后的账号密码
            request.headers['Proxy-Authorization'] = 'Basic ' + b64_data.decode()
            # 设置代理

        else:
            # 免费代理不用认证
            request.meta['proxy'] = proxy['ip_port']

```

settings中设置

```python
DOWNLOADER_MIDDLEWARES = {
   # 'Douban.middlewares.MyCustomDownloaderMiddleware': 543,
   #注册ip代理
    # 'Douban.middlewares.RandomProxy': 544,
}
ip代理(自定)
 PROXY_LIST = [
     {'ip_port': '121.232.148.85:9000'},
     {'ip_port': '115.223.235.157:9000'},
        #收费的ip， 端口    用户名   密码
     {"ip_port": "ip:port", "user_passwd": "user:passwd"}
]
```

# 第六章 Scrapy_Redis组分布式爬虫

## redis教程：

### 概述

`redis`是一种支持分布式的`nosql`数据库,他的数据是保存在内存中，同时`redis`可以定时把内存数据同步到磁盘，即可以将数据持久化，并且他比`memcached`支持更多的数据结构(`string`,`list列表[队列和栈]`,`set[集合]`,`sorted set[有序集合]`,`hash(hash表)`)。相关参考文档：<http://redisdoc.com/index.html>

### redis使用场景：

1. 登录会话存储：存储在`redis`中，与`memcached`相比，数据不会丢失。
2. 排行版/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名。还有一些文章阅读量的技术，或者新浪微博的点赞数等。
3. 作为消息队列：比如`celery`就是使用`redis`作为中间人。
4. 当前在线人数：还是之前的秀场例子，会显示当前系统有多少在线人数。
5. 一些常用的数据缓存：比如我们的`BBS`论坛，板块不会经常变化的，但是每次访问首页都要从`mysql`中获取，可以在`redis`中缓存起来，不用每次请求数据库。
6. 把前200篇文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。
7. 好友关系：微博的好友关系使用`redis`实现。
8. 发布和订阅功能：可以用来做聊天软件。

### `redis`和`memcached`的比较：

|              | memcached                     | redis                          |
| ------------ | ----------------------------- | ------------------------------ |
| 类型         | 纯内存数据库                  | 内存磁盘同步数据库             |
| 数据类型     | 在定义value时就要固定数据类型 | 不需要                         |
| 虚拟内存     | 不支持                        | 支持                           |
| 过期策略     | 支持                          | 支持                           |
| 存储数据安全 | 不支持                        | 可以将数据同步到dump.db中      |
| 灾难恢复     | 不支持                        | 可以将磁盘中的数据恢复到内存中 |
| 分布式       | 支持                          | 主从同步                       |
| 订阅与发布   | 不支持                        | 支持                           |

### `redis`在`ubuntu`系统中的安装与启动

1. 安装：

   ```
    sudo apt-get install redis-server
   ```

2. 卸载：

   ```
    sudo apt-get purge --auto-remove redis-server
   ```

3. 启动：`redis`安装后，默认会自动启动，可以通过以下命令查看：

   ```
    ps aux|grep redis
   ```

   如果想自己手动启动，可以通过以下命令进行启动：

   ```
    sudo service redis-server start
   ```

4. 停止：

   ```
    sudo service redis-server stop
   ```

### redis在windows系统中的安装与启动：

1. 下载：redis官方是不支持windows操作系统的。但是微软的开源部门将redis移植到了windows上。因此下载地址不是在redis官网上。而是在github上：<https://github.com/MicrosoftArchive/redis/releases。>
2. 安装：点击一顿下一步安装就可以了。
3. 运行：进入到`redis`安装所在的路径然后执行`redis-server.exe redis.windows.conf`就可以运行了。
4. 连接：`redis`和`mysql`以及`mongo`是一样的，都提供了一个客户端进行连接。输入命令`redis-cli`（前提是redis安装路径已经加入到环境变量中了）就可以连接到`redis`服务器了。

### 其他机器访问本机redis服务器：

想要让其他机器访问本机的redis服务器。那么要修改redis.conf的配置文件，将bind改成`bind [自己的ip地址或者0.0.0.0]`，其他机器才能访问。
**注意：bind绑定的是本机网卡的ip地址，而不是想让其他机器连接的ip地址。如果有多块网卡，那么可以绑定多个网卡的ip地址。如果绑定到额是0.0.0.0，那么意味着其他机器可以通过本机所有的ip地址进行访问。**

### 对`redis`的操作

对`redis`的操作可以用两种方式，第一种方式采用`redis-cli`，第二种方式采用编程语言，比如`Python`、`PHP`和`JAVA`等。

1. 使用`redis-cli`对`redis`进行字符串操作：

2. 启动`redis`：

   ```
     sudo service redis-server start
   ```

3. 连接上`redis-server`

   ```
     redis-cli -h [ip] -p [端口]
   ```

4. 添加：

   ```
     set key value
     如：
     set username xiaotuo
   ```

   将字符串值`value`关联到`key`。如果`key`已经持有其他值，`set`命令就覆写旧值，无视其类型。并且默认的过期时间是永久，即永远不会过期。

5. 删除：

   ```
     del key
     如：
     del username
   ```

6. 设置过期时间：

   ```
     expire key timeout(单位为秒)
   ```

   也可以在设置值的时候，一同指定过期时间：

   ```
     set key value EX timeout
     或：
     setex key timeout value
   ```

7. 查看过期时间：

   ```
     ttl key
     如：
     ttl username
   ```

8. 查看当前`redis`中的所有`key`：

   ```
     keys *
   ```

9. 列表操作：

   - 在列表左边添加元素：

     ```
       lpush key value
     ```

     将值`value`插入到列表`key`的表头。如果`key`不存在，一个空列表会被创建并执行`lpush`操作。当`key`存在但不是列表类型时，将返回一个错误。

   - 在列表右边添加元素：

     ```
       rpush key value
     ```

     将值value插入到列表key的表尾。如果key不存在，一个空列表会被创建并执行RPUSH操作。当key存在但不是列表类型时，返回一个错误。

   - 查看列表中的元素：

     ```
       lrange key start stop
     ```

     返回列表`key`中指定区间内的元素，区间以偏移量`start`和`stop`指定,如果要左边的第一个到最后的一个`lrange key 0 -1`。

   - 移除列表中的元素：

     - 移除并返回列表

       ```
       key
       ```

       的头元素：

       ```
         lpop key
       ```

     - 移除并返回列表的尾元素：

       ```
       rpop key
       ```

     - 移除并返回列表`key`的中间元素：

       ```
         lrem key count value
       ```

       将删除`key`这个列表中，`count`个值为`value`的元素。

   - 指定返回第几个元素：

     ```
       lindex key index
     ```

     将返回`key`这个列表中，索引为`index`的这个元素。

   - 获取列表中的元素个数：

     ```
       llen key
       如：
       llen languages
     ```

   - 删除指定的元素：

     ```
       lrem key count value
       如：
       lrem languages 0 php
     ```

     根据参数 count 的值，移除列表中与参数 value 相等的元素。`count`的值可以是以下几种：

     - count > 0：从表头开始向表尾搜索，移除与`value`相等的元素，数量为`count`。
     - count < 0：从表尾开始向表头搜索，移除与 `value`相等的元素，数量为`count`的绝对值。
     - count = 0：移除表中所有与`value` 相等的值。

10. `set`集合的操作：

    - 添加元素：

      ```
        sadd set value1 value2....
        如：
        sadd team xiaotuo datuo
      ```

    - 查看元素：

      ```
        smembers set
        如：
        smembers team
      ```

    - 移除元素：

      ```
        srem set member...
        如：
        srem team xiaotuo datuo
      ```

    - 查看集合中的元素个数：

      ```
        scard set
        如：
        scard team1
      ```

    - 获取多个集合的交集：

      ```
        sinter set1 set2
        如：
        sinter team1 team2
      ```

    - 获取多个集合的并集：

      ```
        sunion set1 set2
        如：
        sunion team1 team2
      ```

    - 获取多个集合的差集：

      ```
      sdiff set1 set2
      如：
      sdiff team1 team2
      ```

11. `hash`哈希操作：

    - 添加一个新值：

      ```
        hset key field value
        如：
        hset website baidu baidu.com
      ```

      将哈希表`key`中的域`field`的值设为`value`。
      如果`key`不存在，一个新的哈希表被创建并进行 `HSET`操作。如果域 `field`已经存在于哈希表中，旧值将被覆盖。

    - 获取哈希中的`field`对应的值：

      ```
        hget key field
        如：
        hget website baidu
      ```

    - 删除`field`中的某个`field`：

      ```
        hdel key field
        如：
        hdel website baidu
      ```

    - 获取某个哈希中所有的`field`和`value`：

      ```
        hgetall key
        如：
        hgetall website
      ```

    - 获取某个哈希中所有的`field`：

      ```
        hkeys key
        如：
        hkeys website
      ```

    - 获取某个哈希中所有的值：

      ```
      hvals key
      如：
      hvals website
      ```

    - 判断哈希中是否存在某个`field`：

      ```
      hexists key field
      如：
      hexists website baidu
      ```

    - 获取哈希中总共的键值对：

      ```
      hlen field
      如：
      hlen website
      ```

12. 事务操作：Redis事务可以一次执行多个命令，事务具有以下特征：

    - 隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他命令打扰。

    - 原子操作：事务中的命令要么全部被执行，要么全部都不执行。

    - 开启一个事务：

      ```
        multi
      ```

      以后执行的所有命令，都在这个事务中执行的。

    - 执行事务：

      ```
        exec
      ```

      会将在`multi`和`exec`中的操作一并提交。

    - 取消事务：

      ```
        discard
      ```

      会将`multi`后的所有命令取消。

    - 监视一个或者多个`key`：

      ```
        watch key...
      ```

      监视一个(或多个)key，如果在事务执行之前这个(或这些) key被其他命令所改动，那么事务将被打断。

    - 取消所有`key`的监视：

      ```
        unwatch
      ```

13. 发布/订阅操作：

    - 给某个频道发布消息：

      ```
        publish channel message
      ```

    - 订阅某个频道的消息：

      ```
        subscribe channel
      ```

## Scrapy-Redis分布式爬虫组件

`Scrapy`是一个框架，他本身是不支持分布式的。如果我们想要做分布式的爬虫，就需要借助一个组件叫做`Scrapy-Redis`，这个组件正是利用了`Redis`可以分布式的功能，集成到`Scrapy`框架中，使得爬虫可以进行分布式。可以充分的利用资源（多个ip、更多带宽、同步爬取）来提高爬虫的爬行效率。

### 分布式爬虫的优点：

1. 可以充分利用多台机器的带宽。
2. 可以充分利用多台机器的ip地址。
3. 多台机器做，爬取效率更高。

### 分布式爬虫必须要解决的问题：

1. 分布式爬虫是好几台机器在同时运行，如何保证不同的机器爬取页面的时候不会出现重复爬取的问题。
2. 同样，分布式爬虫在不同的机器上运行，在把数据爬完后如何保证保存在同一个地方。

### 安装：

通过`pip install scrapy-redis`即可安装。

### Scrapy-Redis架构：

Scrapy架构图：
![img](../assets/scrapy_all.png)

Scrapy-Redis架构图：
![img](../assets/scrapy-redis.png)

分布式爬虫架构图：
![img](../assets/fenbushi.png)

以上两个图片对比我们可以发现。`Item Pipeline`在接收到数据后发送给了`Redis`、`Scheduler`调度器调度数据也是从`Redis`中来的、并且其实数据去重也是在`Redis`中做的。

### 编写Scrapy-Redis分布式爬虫：

要将一个`Scrapy`项目变成一个`Scrapy-redis`项目只需修改以下三点就可以了：

1. 将爬虫的类从`scrapy.Spider`变成`scrapy_redis.spiders.RedisSpider`；或者是从`scrapy.CrawlSpider`变成`scrapy_redis.spiders.RedisCrawlSpider`。
2. 将爬虫中的`start_urls`删掉。增加一个`redis_key="xxx"`。这个`redis_key`是为了以后在`redis`中控制爬虫启动的。爬虫的第一个url，就是在redis中通过这个发送出去的。
3. 在配置文件中增加如下配置：

```python
    # Scrapy-Redis相关配置
    # 确保request存储到redis中
    SCHEDULER = "scrapy_redis.scheduler.Scheduler"

    # 确保所有爬虫共享相同的去重指纹
    DUPEFILTER_CLASS = "scrapy_redis.dupefilter.RFPDupeFilter"

    # 设置redis为item pipeline
    ITEM_PIPELINES = {
        'scrapy_redis.pipelines.RedisPipeline': 300
    }

    # 在redis中保持scrapy-redis用到的队列，不会清理redis中的队列，从而可以实现暂停和恢复的功能。
    SCHEDULER_PERSIST = True

    # 设置连接redis信息
    REDIS_HOST = '127.0.0.1'
    REDIS_PORT = 6379
```

1. 运行爬虫：
   1. 在爬虫服务器上。进入爬虫文件所在的路径，然后输入命令：`scrapy runspider [爬虫名字]`。
   2. 在`Redis`服务器上，推入一个开始的url链接：`redis-cli> lpush [redis_key] start_url`开始爬取。

# 第七章 手机App爬取相关

除了Web网页，爬虫也可以抓取App的数据。App中的页面要加载出来，首先需要获取数据，而这些数据一般是通过请求服务器的接口来获取的。由于App没有浏览器这种可以比较直观地看到后台请求的工具，所以主要用一些抓包技术来抓取数据。

抓包工具有Charles、mitmproxy和mitmdump。一些简单的接口可以通过Charles或mitmproxy分析，找出规律，然后直接用程序模拟来抓取了。但是如果遇到更复杂的接口，就需要利用mitmdump对接Python来对抓取到的请求和响应进行实时处理和保存。另外，既然要做规模采集，就需要自动化App的操作而不是人工去采集，所以这里还需要一个工具叫作Appium，它可以像Selenium一样对App进行自动化控制，如自动化模拟App的点击、下拉等操作。

